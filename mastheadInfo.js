module.exports = [
	{
		id: "array-2",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_mock_interview.jpg",
		heading: "Array Max",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers and an integer K, the task is to find the maximum sum taking every K",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Array Max\n\n#### CONCEPTS USED:\nSuffix Sum Arrays\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers and an integer $K$, the task is to find the maximum sum taking every $K^{th}$ element i.e. \n\n$sum$ $= arr[i] + arr[i + k] + arr[i + 2 *k] + arr[i + 3 * k] + ... arr[i+ q * k]$ \n\nstarting with any $i$ value.\n\n**NOTE**: \n1. He can stop moving to \n$(i+k)^{th}$ index\n at any time he wishes.  \n\n2. Minimum value that sum can have is zero, it should never become negative throughout the calculation.  \n\n#### For Example: \n```\nInput : N = 5, K = 2\n        A[] = [1, 2, 3, 4, 5]\n\nOutput : 9\n\nExplanation : Start with index = 0 and sum = 0\n\nsum = sum + A[0] = 0 + 1 = 1\ni = i + 2 = 0 + 2 = 2\n\nsum = sum + A[2] = 2 + 3 = 5\ni = i + 2 = 2 + 2 = 4\n\nsum = sum + A[4] = 4 + 5 = 9\ni = i + 2 = 4 + 2 = 6\n\nSimilarly starting from other indexes and finding sum values, we obtain that\n9 is the maximum sum that can be obtained.\n```\n\n#### BRUTEFORCE METHOD:\n\n1.  Begin with choosing a starting `index`$(i = 0)$, adding value at this `index` to the `sum`, comparing `sum` with `max value` and updating `max value`. Keep taking $K$ steps and updating `max value` till $i$ becomes equal to $N$.\n\n2. Follow `Step-1` for all such `indexes` and finally find the `maximum sum` out of all such sum values.\n  \n3. `Time Complexity` of this solution is $O(N^2)$ as we will be running two nested loops.\n\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    int max_val = 0;\n    int sum = 0;\n    for(int i=0;i<n;i++)\n    {\n      sum = 0;\n      int j=i;\n      while(j<n)\n      {\n        if(sum+arr[j]<0)\n        {\n          sum=0;\n        }\n        else\n   sum += arr[j];\n        if(sum>max_val)\n          max_val = sum;\n        j += k;\n      }\n    }\n    printf(\"%d\n\",max_val);\n  }\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n    for(int i=0;i<n;i++)\n      cin>>arr[i];\n    int max_val = 0;\n    int sum = 0;\n    for(int i=0;i<n;i++)\n    {\n      sum = 0;\n      int j=i;\n      while(j<n)\n      {\n        if(sum+arr[j]<0)\n        {\n       sum=0;\n        }\n        else\n          sum += arr[j];\n        max_val = max(sum,max_val);\n        j += k;\n   }\n    }\n    cout<<max_val<<\"\n\";\n  }\n  \n  return 0;\n}\n```\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0)\n    {\n   int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      for(int i=0;i<n;i++)\n     arr[i] = sc.nextInt();\n      int max_val = 0;\n      int sum = 0;\n      for(int i=0;i<n;i++)\n      {\n        sum = 0;\n        int j=i;\n        while(j<n)\n        {\n          if(sum+arr[j]<0)\n          {\n            sum=0;\n          }\n          else\n            sum += arr[j];\n          if(sum>max_val)\n            max_val = sum;\n j += k;\n        }\n      }\n      System.out.println(max_val);\n      t--;\n    }   \n  }\n}\n```\n\nTime Complexity : $O(N^2)$\n\nSpace Complexity: $O(1)$\n\n\n\n#### EFFICIENT METHOD:\n1. It can be solved by using the concept of `Suffix Sum Arrays` where we start iterating the array from right side and keep storing the suffix sum for each $(i+k)^{th}$ element where $(i+k)<n$.  \n\n2. Finally we find the maximum sum from the `Suffix Sum Array`.\n\n***What are Suffix Sum Arrays?***\n`Suffix Sum Arrays` are of same size of the normal array such that the $i^{th}$ index of this array stores the sum of values from $i{th}$ index value to the last value of the original array i.e.      \n \n$SuffixArray[i] = A[i] + A[i+1] + .... + A[N-1]$ \n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n       scanf(\"%d\",&arr[i]);\n    }\n     \n int max_val = 0;\n    int sum[n];\n    for(int i=0;i<n;i++)\n      sum[i] = 0;\n    \n    for(int i=n-1;i>=0;i--)\n {\n      if(i+k < n)\n      {\n        if(arr[i]+sum[i+k]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i]+sum[i+k];\n      }\n      else\n      {\n        if(arr[i]<0)\n          sum[i] = 0;\n        else\n       sum[i] = arr[i];\n      }\n      if(sum[i]>max_val)\n        max_val = sum[i];\n    }\n    printf(\"%d\n\",max_val);\n  }\n  \n  return 0;\n}\n\n```\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n   for(int i=0;i<n;i++)\n    {\n       cin>>arr[i];\n    }\n     \n    int max_val = 0;\n    int sum[n];\n    for(int i=0;i<n;i++)\n      sum[i] = 0;\n    \n    for(int i=n-1;i>=0;i--)\n    {\n      if(i+k < n)\n      {\n        if(arr[i]+sum[i+k]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i]+sum[i+k];\n      }\n      else\n {\n        if(arr[i]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i];\n      }\n        \n      max_val = max(max_val,sum[i]);\n    }\n    cout<<max_val<<\"\n\";\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n while(t!=0)\n    {\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      for(int i=0;i<n;i++)\n      {\n         arr[i] = sc.nextInt();\n      }\n      int max_val = 0;\n      int sum[] = new int[n];\n      \n      for(int i=n-1;i>=0;i--)\n      {\n        if(i+k < n)\n        {\n          if(arr[i]+sum[i+k]<0)\n            sum[i] = 0;\n          else\n            sum[i] = arr[i]+sum[i+k];\n        }\n        else\n        {\n          if(arr[i]<0)\n            sum[i] = 0;\n          else\n            sum[i] = arr[i];\n        }\n        if(sum[i]>max_val)\n          max_val = sum[i];\n      }\n      System.out.println(max_val);\n      t--;\n    }  \n  }\n}\n```\n#### Can you guess the `Time Complexity` of the `Efficient` solution ? \n\n1. $O(N)$  \n\n2. $O(NlogN)$\n\n3. $O(logN)$\n\n4. $O(N^2)$\n \nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, due to `Suffix Array` taking additional memory.\n"
	},
	{
		id: "recursion-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_face_interview_freshers.jpg",
		heading: "Mike and Binary Number",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given a number N, your task is to print all possible permutations of its Binary Representation.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Mike and Binary Number\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a number $N$, your task is to print all possible permutations of its `Binary Representation`.\n\n***NOTE*** : Print the output in the lexicographically sorted form.\n\n#### For Example :\n\n```\nInput : N = 5\n\nOutput : 011 101 110\n\nExplanation : \n\nBinary Representation of 5 is 101 and all permutations of it i.e. 011 101 110 are printed in a lexicographic order.\n```\n\n#### SOLVING APPROACH:\n\n1. Start by finding the number of zeros and ones present in the `Binary Representation` of $N$ and store them in `ones` and `zeros`.   \n\n2. Initialize an empty string `str` for storing all such combinations one-by-one.\n\n3. If `ones` = 0, append all the `zeros` to `str` and print it. Else if `zeros` = 0, append all `ones` to `str` and print it.\n\n4. Else recursively keep appending a $0$ to `str` and reduce `zeros` by $1$. Similarly recursively keep appending a $1$ to `str` and reduce `ones` by $1$ till all `zeros` and `ones` are appended in the `str` and its size becomes equal to size of the `Binary Representation` of the number $N$.\n\n#### ILLUSTRATION :\n\n```\nN = 5 \nBinary Representation of 5 = 101\nZeros = 1\nOnes = 2\nstr = \"\"\n\nSince Zeros and Ones both are not 0, append 0 to str and reduce Zeros by 1\nstr = \"0\"\nZeros = 0\n\nSince Zeros = 0, append all remaining 1's to str\nstr = \"011\"\nOnes = 0\n\nSince Zeros = Ones = 0\nprint the str i.e. our first valid permutation of Binary Representation of 5.\n\nSimilarly print all such permutations recursively.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* function for finding all such combinations */\nvoid permutation(int no_ones, int no_zeroes, string accum,vector<string>&perm){\n   if(no_ones == 0){\n       for(int i=0;i<no_zeroes;i++){\n     accum += \"0\";\n       }\n       perm.push_back(accum);\n       return;\n   }\n   else if(no_zeroes == 0){\n       for(int j=0;j<no_ones;j++){\n           accum += \"1\";\n       }\n       perm.push_back(accum);\n       return;\n }\n\n   permutation (no_ones - 1, no_zeroes, accum + \"1\",perm);\n   permutation (no_ones , no_zeroes - 1, accum + \"0\",perm);\n}\n\nint main(){\n   int t;\n   cin>>t;\n   while(t--){\n   int n, ones = 0, zeros = 0;\n   cin>>n;\n \n   /* finding number of zeros and ones in the number */\n   while(n>0)\n   {\n       if(n&1)\n           ones++;\n       else\n        zeros++;\n      n =n>>1;    \n   }\n   \n   //initializing an empty string\n   string append = \"\";\n   \n   //vector of strings to store all the combinations \n   vector<string>perm;\n     \n    \n   permutation(ones, zeros, append, perm);  \n   \n   /* sort all combinations in ascending order */\n   sort(perm.begin(),perm.end());\n   \n   for(int i=0;i<perm.size();i++)\n     cout<<perm[i]<<\" \";\n   }\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  \n   /* function for finding all such combinations */\n  static void permutation(int no_ones, int no_zeroes, String accum, ArrayList<String> perm){\n     if(no_ones == 0){\n         for(int i=0;i<no_zeroes;i++){\n             accum += \"0\";\n     }\n         perm.add(accum);\n         return;\n     }\n     else if(no_zeroes == 0){\n         for(int j=0;j<no_ones;j++){\n             accum += \"1\";\n         }\n         perm.add(accum);\n         return;\n     }\n  \n     permutation (no_ones - 1, no_zeroes, accum + \"1\",perm);\n     permutation (no_ones , no_zeroes - 1, accum + \"0\",perm);\n  }\n\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n  \n    while(t != 0){\n    int n = sc.nextInt();\n    int ones = 0, zeros = 0;\n    \n    /* finding number of zeros and ones in the number */\n    while(n>0)\n    {\n       if(n%2 == 0)\n   zeros++;\n       else\n          ones++;\n      n /= 2;    \n    }\n    \n    //initializing an empty string\n    String append = \"\";\n    \n    //vector of strings to store all the combinations \n    //vector<string>perm;\n    ArrayList<String> perm = new ArrayList<String>(); \n     \n    \n    permutation(ones, zeros, append, perm);  \n   \n    /* sort all combinations in ascending order */\n    Collections.sort(perm);\n    \n    for(int i=0;i<perm.size();i++)\n      System.out.print(perm.get(i) + \" \");\n    System.out.println();\n    \n    t--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ? \n\n1. $O(N^2)$  \n\n2. $O(2^N)$\n\n3. $O(N*2^N)$\n\n4. $O(N^2 * 2^N)$\n \n**Time Complexity**: $O(N*2^N)$\n"
	},
	{
		id: "searching-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/start_preparation_blog.jpg",
		heading: "Maximize The Boxes",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given chocolates of 3 types A, B, C with their frequencies f A,f B and f C, you need to pack these chocolates in a box. Maximize the number of boxes for given f A,f B and f C. Q queries will be asked.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Maximize The Boxes \n\n#### CONCEPTS USED:\nSearching, Basic Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven chocolates of $3$ types $A, B, C$ with their frequencies $f_A$,$f_B$ and $f_C$, you need to pack these chocolates in a box. Maximize the number of boxes for given $f_A$,$f_B$ and $f_C$. $Q$ queries will be asked.\n\n#### CONDITIONS:\n\n1. Box should contain exactly $3$ chocolates.  \n\n2. It should contain at least $1$ type of chocolate $A$ and $1$ type of chocolate $B$.\n\nAllowed : $(A,B,C) , (A,A,B), (A,B,B)$ \n\nNot Allowed : $(C,C,A) , (A,A,A)$ $etc$\n\n#### For Example:\n\n```\nInput : 4 2 1\n\nOutput : 2\n\nExplanation : Every box should have atleast 1 chocolate of type A and 1 chocolate of type B, so she have only arrangement possible - \n\n(A B C) => we have single C, which is used here\n(A B A) => out of two B's, last B is used here\n\nTherefore, Maximum of 2 boxes can be made.\n```\n\n```\nInput : 5 4 0\n\nOutput : 3\n\nExplanation : Every box should have at least 1 chocolate of type A and 1 chocolate of type B, so she have only arrangement possible - \n\n(A B A) => 3 A's and 3 B's left\n(A B B) => 2 A's and 1 B left\n(A A B) => all A's and B's used\n\nTherefore, Maximum of 3 boxes can be made.\n```\n\n#### SOLVING APPROACH:\n\n1. The approach is quite simple as there are only two cases to cover.  \n\n2. If `minimum` frequency between A and B is less than or equal to frequency of C, than `minimum` frequency between A and B is our answer, as Chocolate $A$ and $B$ are essential in every box so the `minimum` of these two will be the result.\n\n3. Else if `minimum` frequency between $A$ and $B$ is greater than frequency of $C$, this implies that putting only $1-1$ chocolate $A$ and chocolate $B$ are not sufficient in each box as there are insufficient chocolate $C$ for all such boxes.\n\n4. So, calculate the `Sum` of frequency of all the three boxes and divide it by $3$.\n\n5. The `minimum` between this `Sum` and `minimum` frequency between $A$ and $B$ will be our answer. \n\n#### ALGORITHM:\n\n```\nmin_f_AB = minimum of (frequency of A , frequency of B)\nSum_f_ABC = (frequency of A + frequency of B + frequency of C)/3\n\n\nif (min_f_AB <= frequency of C)\n    print min_f_AB\nelse\n    if(Sum_f_ABC < min_f_AB)\n        print Sum_f_ABC\n    else\n        print min_f_AB\n```\n\n#### ILLUSTRATION:\n\n```\n2 2 2\n\nMin of A and B <= C i.e. (2 <= 2)\nSo, Maximum boxes is Min of A and B i.e. 2\n```\n\n```\n4 2 1 \n\nMin of A and B > C i.e. (2 > 1)\nSo calculate average of all frequencies and check whether it is (< Min of A and B)\nsum = (A + B + C) / 3 = (4 + 2 + 1) / 3 = 2\nSince, sum < Min of A and B\nso sum is our Maximum number of boxes i.e. 2\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int q; scanf(\"%d\", &q);\n  while(q--){\n    int f_a, f_b, f_c, min_ab;\n    scanf(\"%d %d %d\", &f_a, &f_b, &f_c);\n    \n    // find mininum among f_a and f_b\n    if(f_a < f_b)\n      min_ab = f_a;\n    else\n      min_ab = f_b;\n   \n    // print the minimum of (f_a, f_b) and f_c \n    if(min_ab <= f_c){\n      printf(\"%d\n\", min_ab);\n    }\n    \n /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n    else{\n      int sum = (f_a + f_b + f_c)/3;\n      if(sum < min_ab)\n        printf(\"%d\n\", sum);\n      else \n        printf(\"%d\n\", min_ab);\n    }\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int q; cin>>q;\n  while(q--){\n    int f_a, f_b, f_c ;\n    cin>>f_a>>f_b>>f_c ;\n    \n    // print the minimum of (f_a, f_b) and f_c \n    if(min(f_a, f_b) <= f_c){\n      cout<<min(f_a, f_b)<<\"\n\";\n    }\n    \n    /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n    else{\n      int sum = (f_a + f_b + f_c)/3;\n      cout<<min(sum, min(f_a, f_b)) <<\"\n\";\n    }\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\nimport java.lang.Math;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int q = sc.nextInt();\n    \n    while(q != 0){\n      int f_a = sc.nextInt();\n      int f_b = sc.nextInt();\n      int f_c = sc.nextInt();\n     \n      // print the minimum of (f_a, f_b) and f_c \n      if(Math.min(f_a, f_b) <= f_c){\n        System.out.println(Math.min(f_a, f_b));\n }\n      \n      /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n     else{\n        int sum = (f_a + f_b + f_c)/3;\n        System.out.println(Math.min(sum, Math.min(f_a, f_b)));\n     }\n      q--;\n    }\n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(NlogN)$\n\n3. $O(N^2)$\n\n4. $O(N)$\n\nwhere $N =$ $Number$ $of$ $queries$\n \n**Time Complexity**: $O(N)$\n \n**Space Complexity**: $O(1)$"
	},
]