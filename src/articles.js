module.exports = [
	{
		id: "array-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_resume_tips_freshers.jpg",
		heading: "Arithmetic Progression",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers, print the value of all those elements, whose indexes form an increasing",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Arithmetic Progression\n\n#### CONCEPTS USED:\nHashing, Basic Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers, print the value of all those elements, whose indexes form an increasing `Arithmetic Progression` along with the difference in `Arithmetic Progression`. If an element occurs single time then print $0$ as difference.\n\n#### For Example:\n```\nInput: \n\nN = 8\nA[] = [4, 2, 4, 3, 4, 2, 4, 5]\n\nOutput: \n\n4\n2 4\n3 0 \n4 2\n5 0\n\nExplanation:\n\n2 is present at index 1 and 5 which forms an A.P. with common difference 4 \n\n3 is present only at index 3 which is again an A.P. with common difference 0\n\n4 is present at index 0, 2, 4, and 6 which forms an A.P. with common difference 2\n\n5 is present only at index 7 which is again an A.P. with common difference 0\n```\n\n\n#### SOLVING APPROACH:\n\n1. It can be easily solved in `Linear Time Complexity` i.e. $O(N)$ but taking additional $O(N)$ space.\n\n2. Traverse the array and keep putting the elements into a `set`.\nA `set` is a data structure that contains unique elements.\n\n3. Maintain two different arrays for `difference value` and `last value` of an element and keep updating them.\n\n4. If the updated `difference value` does not matches the old value, this implies that the indices of this element are not in `Arithmetic Progression`. Therefore remove the element from the set.\n\n3. Finally print the elements and their `difference value` from the set.\n\n\n#### ILLUSTRATION:\n```\nA[] = [4, 2, 4, 3, 4]\n\ni = 0\nset = { }\n\n\nA[0] = 4 is not present in set, insert it\nset = {4}\ndiff[4] = 0\nlast_index[4] = i = 0\ni++;\n\ni = 1\nA[1] = 2 is not present in set, insert it\nset = {2, 4}\ndiff[2] = 0\nlast_index[2] = i =  1\ni++;\n\ni = 2\nA[2] = 4 is present in set, update last_index and difference\ndiff[4] = i - last_index[4] = 2 - 0 = 2\nlast_index[4] = i =  2\ni++;\n\ni = 3\nA[3] = 3 is not present in set, insert it\nset = {2, 3, 4}\ndiff[3] = 0\nlast_index[3] = i = 3\ni++ ;\n\ni = 4\nA[4] = 4 is present in set, update last_index and difference\n(if updated diff is not equal to previous diff, erase this element)\ndiff[4] = i - last_index[4] = 4 - 2 = 2\nlast_index[4] = i = 4\n\nNow print all elements of set along with their differences\n\nset = {2, 3, 4}\n\n3   (size of set)\n2 0 (diff[2])\n3 0 (diff[3])\n4 2 (diff[4])\n```\n\n\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint a1[100001],a2[100001];\nint b1[100001];\nint main() {\n    int n,a,o=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i) {\n        scanf(\"%d\",&a);\n    if(b1[a])\n        continue;\n    if(a1[a]) {\n        if(!a2[a])\n            a2[a]=i-a1[a];\n        else if(a2[a]!=i-a1[a])\n        {\n            b1[a]=1;--o;\n        }\n    }\n        else ++o;\n        a1[a]=i;\n   }\n    printf(\"%d\n\",o);\n    for(int i=1;i<100001;++i)\n        if(a1[i]&&!b1[i])\n            printf(\"%d %d\n\",i,a2[i]);\n}  \n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include<bits/stdc++.h>\n    using namespace std;\n    typedef long long int ll;\n    int main(){\n        ll n,a;\n        cin>>n;\n        ll diff[100005]={0},last_value[100005]={0};\n        bool b[100005];\n        set<ll>s;\n        memset(b,false,sizeof(b));\n     for(ll i=1;i<=n;i++){\n            cin>>a;\n            if(!b[a]){\n                s.insert(a);\n                b[a]=true;\n            }\n            else{\n                if(diff[a]&&(i!=diff[a]+last_value[a])){\n             s.erase(a);\n                }\n                diff[a]=i-last_value[a];\n            }\n            last_value[a]=i;\n        }\n        cout<<s.size()<<endl;\n        for(auto it=s.begin();it!=s.end();it++){\n            cout<<*it<<\" \"<<diff[*it]<<endl;\n        }\n    }\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n ```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int a1[] = new int[100001];\n    int a2[] = new int[100001];\n int b1[] = new int[100001];\n    int n = sc.nextInt();\n    int a,o=0;\n    \n    for(int i=1;i<=n;++i) {\n        a = sc.nextInt();\n    if(b1[a]>0)\n        continue;\n    if(a1[a]>0) {\n        if(a2[a] < 1)\n            a2[a]=i-a1[a];\n        else if(a2[a]!=i-a1[a])\n        {\n            b1[a]=1;--o;\n        }\n    }\n        else ++o;\n        a1[a]=i;\n    }\n    System.out.println(o);\n    for(int i=1;i<100001;++i)\n        if(a1[i]>0 && b1[i]<1)\n          System.out.println(i + \" \" + a2[i]);\n  }\n}\n ```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(N^2)$  \n\n2. $O(N*logN)$\n\n3. $O(logN)$\n\n4. $O(N)$\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, additional space used for `Hashing`.\n"
	},
	{
		id: "array-2",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_mock_interview.jpg",
		heading: "Array Max",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers and an integer K, the task is to find the maximum sum taking every K",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Array Max\n\n#### CONCEPTS USED:\nSuffix Sum Arrays\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers and an integer $K$, the task is to find the maximum sum taking every $K^{th}$ element i.e. \n\n$sum$ $= arr[i] + arr[i + k] + arr[i + 2 *k] + arr[i + 3 * k] + ... arr[i+ q * k]$ \n\nstarting with any $i$ value.\n\n**NOTE**: \n1. He can stop moving to \n$(i+k)^{th}$ index\n at any time he wishes.  \n\n2. Minimum value that sum can have is zero, it should never become negative throughout the calculation.  \n\n#### For Example: \n```\nInput : N = 5, K = 2\n        A[] = [1, 2, 3, 4, 5]\n\nOutput : 9\n\nExplanation : Start with index = 0 and sum = 0\n\nsum = sum + A[0] = 0 + 1 = 1\ni = i + 2 = 0 + 2 = 2\n\nsum = sum + A[2] = 2 + 3 = 5\ni = i + 2 = 2 + 2 = 4\n\nsum = sum + A[4] = 4 + 5 = 9\ni = i + 2 = 4 + 2 = 6\n\nSimilarly starting from other indexes and finding sum values, we obtain that\n9 is the maximum sum that can be obtained.\n```\n\n#### BRUTEFORCE METHOD:\n\n1.  Begin with choosing a starting `index`$(i = 0)$, adding value at this `index` to the `sum`, comparing `sum` with `max value` and updating `max value`. Keep taking $K$ steps and updating `max value` till $i$ becomes equal to $N$.\n\n2. Follow `Step-1` for all such `indexes` and finally find the `maximum sum` out of all such sum values.\n  \n3. `Time Complexity` of this solution is $O(N^2)$ as we will be running two nested loops.\n\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    int max_val = 0;\n    int sum = 0;\n    for(int i=0;i<n;i++)\n    {\n      sum = 0;\n      int j=i;\n      while(j<n)\n      {\n        if(sum+arr[j]<0)\n        {\n          sum=0;\n        }\n        else\n   sum += arr[j];\n        if(sum>max_val)\n          max_val = sum;\n        j += k;\n      }\n    }\n    printf(\"%d\n\",max_val);\n  }\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n    for(int i=0;i<n;i++)\n      cin>>arr[i];\n    int max_val = 0;\n    int sum = 0;\n    for(int i=0;i<n;i++)\n    {\n      sum = 0;\n      int j=i;\n      while(j<n)\n      {\n        if(sum+arr[j]<0)\n        {\n       sum=0;\n        }\n        else\n          sum += arr[j];\n        max_val = max(sum,max_val);\n        j += k;\n   }\n    }\n    cout<<max_val<<\"\n\";\n  }\n  \n  return 0;\n}\n```\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0)\n    {\n   int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      for(int i=0;i<n;i++)\n     arr[i] = sc.nextInt();\n      int max_val = 0;\n      int sum = 0;\n      for(int i=0;i<n;i++)\n      {\n        sum = 0;\n        int j=i;\n        while(j<n)\n        {\n          if(sum+arr[j]<0)\n          {\n            sum=0;\n          }\n          else\n            sum += arr[j];\n          if(sum>max_val)\n            max_val = sum;\n j += k;\n        }\n      }\n      System.out.println(max_val);\n      t--;\n    }   \n  }\n}\n```\n\nTime Complexity : $O(N^2)$\n\nSpace Complexity: $O(1)$\n\n\n\n#### EFFICIENT METHOD:\n1. It can be solved by using the concept of `Suffix Sum Arrays` where we start iterating the array from right side and keep storing the suffix sum for each $(i+k)^{th}$ element where $(i+k)<n$.  \n\n2. Finally we find the maximum sum from the `Suffix Sum Array`.\n\n***What are Suffix Sum Arrays?***\n`Suffix Sum Arrays` are of same size of the normal array such that the $i^{th}$ index of this array stores the sum of values from $i{th}$ index value to the last value of the original array i.e.      \n \n$SuffixArray[i] = A[i] + A[i+1] + .... + A[N-1]$ \n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n       scanf(\"%d\",&arr[i]);\n    }\n     \n int max_val = 0;\n    int sum[n];\n    for(int i=0;i<n;i++)\n      sum[i] = 0;\n    \n    for(int i=n-1;i>=0;i--)\n {\n      if(i+k < n)\n      {\n        if(arr[i]+sum[i+k]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i]+sum[i+k];\n      }\n      else\n      {\n        if(arr[i]<0)\n          sum[i] = 0;\n        else\n       sum[i] = arr[i];\n      }\n      if(sum[i]>max_val)\n        max_val = sum[i];\n    }\n    printf(\"%d\n\",max_val);\n  }\n  \n  return 0;\n}\n\n```\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n   for(int i=0;i<n;i++)\n    {\n       cin>>arr[i];\n    }\n     \n    int max_val = 0;\n    int sum[n];\n    for(int i=0;i<n;i++)\n      sum[i] = 0;\n    \n    for(int i=n-1;i>=0;i--)\n    {\n      if(i+k < n)\n      {\n        if(arr[i]+sum[i+k]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i]+sum[i+k];\n      }\n      else\n {\n        if(arr[i]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i];\n      }\n        \n      max_val = max(max_val,sum[i]);\n    }\n    cout<<max_val<<\"\n\";\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n while(t!=0)\n    {\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      for(int i=0;i<n;i++)\n      {\n         arr[i] = sc.nextInt();\n      }\n      int max_val = 0;\n      int sum[] = new int[n];\n      \n      for(int i=n-1;i>=0;i--)\n      {\n        if(i+k < n)\n        {\n          if(arr[i]+sum[i+k]<0)\n            sum[i] = 0;\n          else\n            sum[i] = arr[i]+sum[i+k];\n        }\n        else\n        {\n          if(arr[i]<0)\n            sum[i] = 0;\n          else\n            sum[i] = arr[i];\n        }\n        if(sum[i]>max_val)\n          max_val = sum[i];\n      }\n      System.out.println(max_val);\n      t--;\n    }  \n  }\n}\n```\n#### Can you guess the `Time Complexity` of the `Efficient` solution ? \n\n1. $O(N)$  \n\n2. $O(NlogN)$\n\n3. $O(logN)$\n\n4. $O(N^2)$\n \nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, due to `Suffix Array` taking additional memory.\n"
	},
	{
		id: "array-3",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_clear_aptitude_test.jpg",
		heading: "Array ZigZag",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers, convert it into a ZigZag array by choosing any element",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Array ZigZag\n\n#### CONCEPTS USED:\nArrays\n\n#### DIFFICULTY LEVEL:\nHard\n\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers, convert it into a `ZigZag` array by choosing any element and decrementing it by $1$.\n\nAn array $A$ is a `ZigZag` array if either:\n\n1. Every even-indexed element is greater than its adjacent elements, ie. $A0 > A1 < A2 > A3 < A4 > ...$\n\n2. OR, every odd-indexed element is greater than its adjacent elements, ie. $A0 < A1 > A2 < A3 > A4 < ...$\n\nPrint the minimum number of moves to transform the given array into a `ZigZag` array.\n\n#### For Example:\n```\nInput: N = 3 \n       A[] = [2, 3, 4]\n\nOutput: 2\n\nExplanation: \n\nWe can decrease 3 to 1 to form [2, 1, 4] so that all even indexed elements are greater than the neighbours. Hence output is 2.\n```\n\n#### SOLVING APPROACH:\n\n>1. We will solve this problem two times.\n>>1. For the even-indexed array.  \n>>\n>>2. For the odd-indexed array.\n>2. `Minimum` of both the solutions will be our desired solution.  \n>\n>2. Start traversing the array, for each element find the `minimum` value among the element , previous element $- 1$ and next element $- 1$.\n>3. The difference between current element and calculated `minimum` value is the moves required to correctly position these three elements.\n>3. Similarly, keep doing it for the entire array and keep track of a `sum` variable.\n>>$sum$   $+= ( A[i] - min(A[i],A[i-1]-1,A[i+1]-1) )$\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint solve(int arr[],int n,int start)\n{\n  int res = 0;\n  for(int i=start;i<n;i+=2)\n  {\n    int to = arr[i];\n    if(i)\n    // make sure current element is less than its left neighboor\n    {\n      if(arr[i-1]-1<to)\n        to = arr[i-1]-1;\n    }\n    if(i+1 != n)\n    // make sure current element is less than its right neighboor\n    {\n      if(arr[i+1]-1<to)\n        to = arr[i+1]-1;\n    }\n // if curr value was decreased to \"to\", add the difference\n    res += arr[i] - to;\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  int arr[n];\n  for(int i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);\n  int res1 = solve(arr,n,0);\n  int res2 = solve(arr,n,1);\n  \n  if(res1 < res2)\n    printf(\"%d\",res1);\n  else\n    printf(\"%d\",res2);\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int arr[],int n,int start)\n{\n  int res = 0;\n  for(int i=start;i<n;i+=2)\n  {\n    int to = arr[i];\n    if(i){\n    // make sure current element is less than its left neighboor\n     to = min(to,arr[i-1]-1);\n    }\n    if(i+1 != n){\n    // make sure current element is less than its right neighboor\n      to = min(to,arr[i+1]-1);\n    }\n    // if curr value was decreased to \"to\", add the difference\n    res += arr[i] - to;\n  }\n  return res;\n}\n\nint main()\n{\n  int n;cin>>n;\n  int arr[n];\n  for(int i=0;i<n;i++)\n cin>>arr[i];\n  \n  cout<<min(solve(arr,n,0),solve(arr,n,1));\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\nimport java.lang.Math;\n\npublic class Main {\n  static int solve(int arr[],int n,int start)\n  {\n    int res = 0;\n    for(int i=start;i<n;i+=2)\n    {\n      int to = arr[i];\n      if(i>0)\n      // make sure current element is less than its left neighboor\n        to = Math.min(to,arr[i-1]-1);\n      if(i+1 != n)\n      // make sure current element is less than its right neighboor\n     to = Math.min(to,arr[i+1]-1);\n      // if curr value was decreased to \"to\", add the difference\n      res += arr[i] - to;\n    }\n    return res;\n  }\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int arr[] = new int[n];\n    for(int i=0;i<n;i++)\n      arr[i] = sc.nextInt();\n    \n    System.out.println(Math.min(solve(arr,n,0),solve(arr,n,1)));\n  }\n}\n ```\n\n#### Can you guess the `Time Complexity` of the solution ? \n1. $O(N)$  \n\n2. $O(N*logN)$\n\n3. $O(logN)$\n\n4. $O(N^2)$\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$\n"
	},
	{
		id: "array-4",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_coding_mistakes.jpg",
		heading: "Benchmates",
		category: "Array",
		date: "August 21 2019",
		desc: "Given marks of N students sitting on a bench and a value of K, print the index of the student whose marks matches with the value of K.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Benchmates\n\n#### CONCEPTS USED:\nEfficient Array Search \n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven marks of $N$ students sitting on a bench and a value of $K$, print the index of the student whose marks matches with the value of $K$. \n\n#### For Example: \n```\nInput : N = 10, K = 67\n        A[] = [60, 61, 62, 63, 63, 64, 65, 66, 67, 66]\n\nOutput : 8\n\nExplanation : 67 is present at 8th index (0-based indexing)\n```\n\n#### SOLVING APPROACH:\n\n#### BRUTEFORCE METHOD\n\n1. Linearly traverse the array, if the value of $K$ matches with any element, print its `index value` else print `-1`.   \n\n2. `Time Complexity` of this solution is $O(N)$.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    int arr[n];\n    int flag=0;\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    for(int i=0;i<n;i++)\n    {\n      if(arr[i]==k)\n      {\n        printf(\"%d\n\",i);\n        flag=1;\n        break;\n      }\n    }\n    if(flag==0)\n      printf(\"-1\n\");\n    \n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n int arr[n];\n    int flag=0;\n    for(int i=0;i<n;i++)\n      cin>>arr[i];\n    for(int i=0;i<n;i++)\n    {\n      if(arr[i]==k)\n      {\n        cout<<i<<\"\n\";\n        flag=1;\n        break;\n      }\n    }\n    if(flag==0)\n      cout<<\"-1\n\";\n  }\n  return 0;\n}\n```\n \nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$\n\n#### EFFICIENT METHOD:\n\n1. The idea is to use the property that every element is obtained either by adding $1$ or $-1$ to the previous element. Let the element to be searched is $X$.   \n\n2. Check if the value at starting index $(i=0)$ matches with $X$, if `Yes` return $i$ else there is a possibility of $X$ being present at $(i + abs(A[i] - X))$ index so  increment $i$ with $abs(A[i] - X)$.\n\n3. Keep incrementing value of $i$, if $X$ is found return $i$ else return $-1$.\n\n4. This is an `Efficient Approach` and works better than the `Naive Solution`.\n\n#### ILLUSTRATION:\n\n```\nA[] = [60, 61, 62, 63, 63, 64, 65, 66, 67, 66]\nK = 67\ni = 0\n\nA[0] != K\ni = i + abs(A[0] - K) = 0 + (60 - 67) = 7\n\nA[7] != K \ni = i + abs(A[7] - X) = 7 + (66 - 67) = 7 + 1 = 8\n\nA[8] = K\nHence we found our K at index = 8.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    int arr[n];\n   int flag=0;\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    \n    int i = 0;\n    while(i<=n-1)\n    {\n      if(arr[i]==k)\n      {\n        printf(\"%d\n\",i);\n        break;\n      }\n      else\n        i += abs(arr[i]-k);\n    }\n    if(i>n-1)\n    {\n      printf(\"-1\n\");\n    }\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n    int flag=0;\n    for(int i=0;i<n;i++)\n     cin>>arr[i];\n    \n    int i = 0;\n    while(i<=n-1)\n    {\n      if(arr[i]==k)\n      {\n        cout<<i<<\"\n\";\n        break;\n      }\n      else\n        i += abs(arr[i]-k);\n    }\n    if(i>n-1)\n    {\n      cout<<\"-1\n\";\n    }\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0)\n    {\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      int flag=0;\n      for(int i=0;i<n;i++)\n arr[i] = sc.nextInt();\n      for(int i=0;i<n;i++)\n      {\n        if(arr[i]==k)\n        {\n          System.out.println(i);\n          flag=1;\n          break;\n        }\n      }\n      if(flag==0)\n        System.out.println(\"-1\");\n      t--;\n    }\n    \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of this solution ? \n1. $O(sqrt(N))$  \n\n2. $O(logN)$\n\n3. $O(NlogN)$\n\n4. $O(N)$\n\nTime Complexity: $O(N)$, in `Worst Case` else it will always work better than the `Naive Approach`.\n\nSpace Complexity: $O(1)$\n\n"
	},
	{
		id: "array-5",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_mistakes_hr_interviews.png",
		heading: "Denomination",
		category: "Array",
		date: "August 21 2019",
		desc: "Given various currency notes (1,2,5,10,20,50,100,500,1000) and N rupees. Print the minimum number of currency notes required to exchange for the value of N.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Denomination\n\n#### CONCEPTS USED:\nBasic Mathematics\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven various currency notes $($$1$,$2$,$5$,$10$,$20$,$50$,$100$,$500$,$1000$$)$ and $N$ rupees. Print the minimum number of currency notes required to exchange for the value of $N$.\n\n#### OBSERVATION:\n\nWe need to find the minimum number of notes so we will pick notes with highest values possible to reach the value of $N$. \n\n#### For Example :\n\n```\nInput: N = 90\n\nOutput: 3\n\nExplanation: 1 note of 50 and 2 notes of 20 will give 90\n```\n```\nInput: N = 100\n\nOutput: 1\n\nExplanation: 1 note of 100 is enough to give 100 \n```\n\n#### SOLVING APPROACH:\n\n1. Store all the currency note values in an array in ascending order. $(1,2,5,10,20,50,100,500,1000)$\n\n2. Now start traversing the array from Right to Left as higher values are stored at the righter half of the array and we are required to find the minimum no. of denominations.\n\n3. If the value of $N$ is greater than the current array element, this implies that we can make use of this currency note.\n\n4. Simply divide $N$ with the value of the current array element and the result gives us the number of this specific currency note that can be given. Store this value in a variable, say Total and reduce the value of $N$ to $N$% arr[current].\n\n5. Repeat the same process until the entire array is traversed.\n\nTotal gives us the minimum number of denominations required to be paid.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n;\n    scanf(\"%d\",&n);\n    int arr[9]={1,2,5,10,20,50,100,500,1000};\n    int note_count=0;\n    for(int i=8;i>=0;i--)\n    {\n      if(arr[i]<=n)\n      {\n        note_count += n/arr[i];\n        n %= arr[i];\n      }\n    }\n    printf(\"%d\n\",note_count);\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n  int n;cin>>n;\n  int arr[9]={1,2,5,10,20,50,100,500,1000};\n  int note_count=0;\n  for(int i=8;i>=0;i--)\n  {\n    if(arr[i]<=n)\n    {\n      note_count += n/arr[i];\n      n %= arr[i];\n    }\n  }\n    cout<<note_count<<\"\n\";\n  }\n \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0)\n    {\n      int n = sc.nextInt();\n      int arr[] = {1,2,5,10,20,50,100,500,1000};\n      int note_count=0;\n      for(int i=8;i>=0;i--)\n      {\n        if(arr[i]<=n)\n        {\n          note_count += n/arr[i];\n          n %= arr[i];\n   }\n      }\n      System.out.println(note_count);\n      t--;\n    }\n    \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of this solution ?\n\n1. $O(sqrt(N))$  \n\n2. $O(logN)$\n\n3. $O(NlogN)$\n\n4. $O(N)$\n\nTime Complexity: $O(N)$, where $N$ is the number of different currency notes.\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "linklist-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_gd_mistakes.png",
		heading: "Binary list",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a linked list of N nodes, each node containing binary bit either 0 or 1 as a character. Your task is to arrange nodes in such a way that no two consecutive nodes contain the same bit.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Binary list\n\n#### CONCEPTS USED:\nBasic Manipulation\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a linked list of $N$ nodes, each node containing binary bit either $0$ or $1$ as a character. Your task is to arrange nodes in such a way that no two consecutive nodes contain the same bit.\n   \n***NOTE*** : The list must start from $0$ if there is more than one bit.  \n\n#### For Example:\n\n```\nInput : 100101\n\nOutput: 010101\n\nExplaination : As count of 0's and 1's are equal i.e. 3, so they can be arranged accordingly.\n```\n\n```\nInput : 11001\n\nOutput: -1\n\nExplaination : As count of 1's is greater than count of 0's, given string cannot be arranged in the required fashion.\n```\n\n#### OBSERVATION :\nWe can arrange our string in the required fashion if any of the two conditions are met - \n\ncount of $0$'s is equal to count of $1$'s \n\ncount of $0$'s is equal to count of $1$'s $+ 1$\n\n#### SOLVING APPROACH:\n\n1. Calculate the count of $0$'s and $1$'s in `zeros` and `ones`.  \n\n2. Check if the string is empty or contains only $1$ char, in this case our string is already arranged so return.\n\n3. Check if `zeros` = `ones` or `zeros` = `ones + 1`, if true one-by-one keep assigning the values of $0$ and $1$ to the string linearly. Else return.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\nNode* BinaryList(Node *head)\n{\n    /* If list is empty or it contains only 1 bit */\n    if(head == NULL || head -> next == NULL)\n      return head;\n      \n    Node *temp = head;\n    int ones = 0, zeros = 0;\n    \n    /* Calculate count of 0's and 1's in the list */\n    while(temp){\n      if(temp -> value == '1')\n        ones++ ;\n      else\n        zeros++ ;\n      temp = temp -> next;\n    }\n    \n    temp = head;\n    int flag = 1;\n    \n    /* if count of 0's and 1's is valid arrange them accordingly */\n    if((zeros == ones) || (zeros == (ones + 1))){\n   while(temp){\n        if(flag){\n          temp -> value = '0';\n          flag = 0;\n        }\n        else{\n   temp -> value = '1';\n          flag = 1;\n        }\n        temp = temp -> next;\n      }\n      return head;\n   }\n    \n    /* if count of 0's and 1's is not valid return NULL */\n    else\n      return NULL;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\nNode* BinaryList(Node *head)\n{\n    /* If list is empty or it contains only 1 bit */\n    if(head == NULL || head -> next == NULL)\n      return head;\n      \n    Node *temp = head;\n   int ones = 0, zeros = 0;\n    \n    /* Calculate count of 0's and 1's in the list */\n    while(temp){\n      if(temp -> value == '1')\n        ones++ ;\n      else\n        zeros++ ;\n      temp = temp -> next;\n    }\n    \n    temp = head;\n    int flag = 1;\n    \n    /* if count of 0's and 1's is valid arrange them accordingly */\n    if((zeros == ones) || (zeros == (ones + 1))){\n      while(temp){\n        if(flag){\n          temp -> value = '0';\n flag = 0;\n        }\n        else{\n          temp -> value = '1';\n          flag = 1;\n        }\n        temp = temp -> next;\n      }\n      return head;\n    }\n    \n    /* if count of 0's and 1's is not valid return NULL */\n    else\n      return NULL;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nstatic SinglyLinkedListNode BinaryList(SinglyLinkedListNode head)\n{\n    /* If list is empty or it contains only 1 bit */\n    if(head == null || head.next == null)\n      return head;\n      \n    SinglyLinkedListNode temp = head;\n    int ones = 0, zeros = 0;\n    \n    /* Calculate count of 0's and 1's in the list */\n    while(temp != null){\n      if(temp.value == '1')\n        ones++ ;\n      else\n        zeros++ ;\n      temp = temp.next;\n    }\n    \n    temp = head;\n int flag = 1;\n    \n    /* if count of 0's and 1's is valid arrange them accordingly */\n    if((zeros == ones) || (zeros == (ones + 1))){\n      while(temp != null){\n        if(flag == 1){\n          temp.value = '0';\n         flag = 0;\n        }\n        else{\n          temp.value = '1';\n          flag = 1;\n        }\n        temp = temp.next;\n      }\n      return head;\n    }\n    \n    /* if count of 0's and 1's is not valid return NULL */\n   else\n      return null;\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(logN)$  \n\n2. $O(N*logN)$\n\n3. $O(N)$\n\n4. $O(N^2)$\n\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "linklist-2",
		img: "https://img.youtube.com/vi/_y8k37Pt-tk/maxresdefault.jpg",
		heading: "Contest Winner",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a circular linked list containing $N$ elements from 1 - N arranged in increasing order and an integer M. Your task is to keep eliminating M'th element from the list, starting from the beginning till only one element is left in the list.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Contest Winner\n\n#### CONCEPTS USED:\nJosephus Problem\n\n#### DIFFICULTY LEVEL:\nHard \n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven a circular linked list containing $N$ elements from $1$ - $N$ arranged in increasing order and an integer $M$. Your task is to keep eliminating $M^{th}$ element from the list, starting from the beginning till only one element is left in the list.\n \n***NOTE*** :  First, eliminates the $M^{th}$ element from the beginning, then again start eliminating from $(M+1)^{th}$ element. \n\n#### For Example:\n\n```\nInput : \n\nN = 5, K = 3\nlist = 1 -> 2 -> 3 -> 4 -> 5\n\nOutput : 4\n\nExplanation : \n\nThe 3rd element from the starting position is 3 which is removed first, 4 becomes new starting position\n\n1 -> 2 -> 4 -> 5\n\nThen the 3rd element from position 4 i.e. 1 is removed, 2 becomes new starting position\n\n2 -> 4 -> 5\n\nThen 3rd element from position 2 i.e. 5 is removed, 2 again becomes new starting position\n\n2 -> 4\n\nThen 3rd element from position 2 i.e. 2 itself is removed\n\n4 is the single element left and is the resultant element.\n```\n\n***Do you Know ?***\nThis is a popular problem known as `Josephus Problem` related to a certain counting-out game.\n\nPeople are standing in a circle waiting to be executed. Counting begins at a specified point in the circle and proceeds around the circle in a specified direction. After a specified number of people are skipped, the next person is executed. The procedure is repeated with the remaining people, starting with the next person, going in the same direction and skipping the same number of people, until only one person remains, and is freed.\n\n#### SOLVING APPROACH:\n\n#### BRUTE FORCE METHOD:\n\n1. The idea is to simply move the `head` pointer of the linked list by $K$ steps and and removing the $K^{th}$ node, by assigning the $(K+1)^{th}$ node address to the `next` pointer of $(K-1)^{th}$ node.    \n  \n2. Now considering $(K+1)^{th}$ node as our new `head`, keep following the same procedure till a single element is left in the linked list.\n\n3. `Time Complexity` of this solution is $O(N^2)$.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\ntypedef struct node\n{\n    int value;\n    struct node* next;\n}node;\n\nstruct node* getNode (struct node *head, int val)\n{\n    struct node *element = (struct node*) malloc(sizeof(struct node));\n    element->value = val ;\n    element->next = NULL ;\n    struct node *temp = head ;\n    if ( head == NULL ) {\n        head = element ;\n        head->next = head ;\n        return head ;\n    }\n    while (temp->next != head)\n        temp = temp->next ;\n    temp->next = element ;\n    element->next = head ;\n    return head ;\n}\n\nstruct node* ContestWinner(struct node *head, int k, int n)\n{\n    node *temp = head;\n    \n    /* finding the previous node of head */\n    while(temp->next != head){\n      temp = temp->next;\n    }\n    \n    node *it = head;\n    node *prev = temp;\n    while(n)\n    {\n        /* if only 1 element is left return it*/\n       if(n == 1)\n        {\n            return it;\n            break;\n        }\n        int size = n;\n        int kk;\n        if(k > size){\n          if(k%size == 0){\n            kk = size;\n          }\n          else{\n       kk = k%size;\n          }\n        }\n        else\n          kk = k;\n          \n        \n        /* increment steps by k to reach the node to be deleted */\n        for(int i=0;i<kk-1;i++){\n          prev = it;\n          it = it->next;\n        }\n        /* delete the node by making its previous node point to its next node */       \n   prev->next = it->next;\n        it = prev->next;\n      \n      /* decrement the count of nodes */  \n      n--;\n \n    }\n}\n\nint main() {\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        struct node *head = NULL, *temp ;\n        int size, i, val, M;\n\n        scanf(\"%d %d\",&size, &M);\n\n        for ( i = 0 ; i < size ; i ++ ) {\n            scanf(\"%d\",&val);\n            head = getNode(head, val) ;\n        }\n        temp = ContestWinner(head, M, size) ;\n        if ( temp != NULL )\n            printf(\"%d\n\", temp->value) ;\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct node\n{\n    int value;\n    struct node* next;\n}node;\n\nnode* getNode (node *head, int val)\n{\n    node *element = new node;\n    element->value = val ;\n    element->next = NULL ;\n    node *temp = head ;\n    if ( head == NULL ) {\n        head = element ;\n        head->next = head ;\n        return head ;\n    }\n    while (temp->next != head)\n        temp = temp->next ;\n    temp->next = element ;\n    element->next = head ;\n    return head ;\n}\n\nstruct node* ContestWinner(struct node *head, int k, int n)\n{\n    node *temp = head;\n    \n    /* finding the previous node of head */\n    while(temp->next != head){\n      temp = temp->next;\n    }\n    \n    node *it = head;\n    node *prev = temp;\n    while(n)\n    {\n        /* if only 1 element is left return it*/\n     if(n == 1)\n        {\n            return it;\n        }\n        int size = n;\n        int kk;\n        if(k > size){\n          if(k%size == 0){\n            kk = size;\n          }\n          else{\n            kk = k%size;\n }\n        }\n        else\n          kk = k;\n          \n        \n        /* increment steps by k to reach the node to be deleted */\n        for(int i=0;i<kk-1;i++){\n          prev = it;\n          it = it->next;\n        }\n /* delete the node by making its previous node point to its next node */       \n        prev->next = it->next;\n   it = prev->next;\n      \n      /* decrement the count of nodes */  \n      n--;\n  \n    }\n}\n\nint main() {\n   int t;\n    cin>>t;\n    while(t--){\n        node *head = NULL, *temp ;\n        int size, i, val, M;\n\n        cin>>size>>M;\n\n        for ( i = 0 ; i < size ; i ++ ) {\n            cin>>val;\n            head = getNode(head, val) ;\n        }\n        temp = ContestWinner(head, M, size) ;\n        if ( temp != NULL )\n            cout<< temp->value<<endl ;\n    }\n    return 0;\n}\n```\n\n#### EFFICIENT METHOD:\n\n#### OBSERVATION:\n\n***Taking few different values of $n$ and $k$, we can construct the following table :***\n\n| n / k | 1  | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|-----|----|---|---|---|---|---|---|---|---|----|\n| 1   | 1  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1  |\n| 2   | 2  | 1 | 2 | 1 | 2 | 1 | 2 | 1 | 2 | 1  |\n| 3   | 3  | 3 | 2 | 2 | 1 | 1 | 3 | 3 | 2 | 2  |\n| 4   | 4  | 1 | 1 | 2 | 2 | 3 | 2 | 3 | 3 | 4  |\n| 5   | 5  | 3 | 4 | 1 | 2 | 4 | 4 | 1 | 2 | 4  |\n| 6   | 6  | 5 | 1 | 5 | 1 | 4 | 5 | 3 | 5 | 2  |\n| 7   | 7  | 7 | 4 | 2 | 6 | 3 | 5 | 4 | 7 | 5  |\n| 8   | 8  | 1 | 7 | 6 | 3 | 1 | 4 | 4 | 8 | 7  |\n| 9   | 9  | 3 | 1 | 1 | 8 | 7 | 2 | 3 | 8 | 8  |\n| 10  | 10 | 5 | 4 | 5 | 3 | 3 | 9 | 1 | 7 | 8  |\n\n\n```\nWith the help of the above table we can observe that the problem has below Recursive Structure :-\n\n  Josephus(n, k) = (Josephus(n - 1, k) + k-1) % n + 1\n  \n  Josephus(1, k) = 1\n\nAs for any value of k, if the number of elements is 1, then it will be our answer.\n```\n\n1. Now we can easily find the solution of `Josephus(n, k)` with the help of `Josephus(n - 1, k)`.\n\n2. For this simply run a loop till `n` and keep calculating -   \n`result = (result + k-1) % i + 1`  \nwhere `(1 <= i <= n)`  \n\n3. This `result` is the element that will remain till the end.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\ntypedef struct node\n{\n    int value;\n    struct node* next;\n}node;\n\nstruct node* getNode (struct node *head, int val)\n{\n    struct node *element = (struct node*) malloc(sizeof(struct node));\n    element->value = val ;\n    element->next = NULL ;\n    struct node *temp = head ;\n    if ( head == NULL ) {\n        head = element ;\n        head->next = head ;\n        return head ;\n    }\n    while (temp->next != head)\n        temp = temp->next ;\n    temp->next = element ;\n    element->next = head ;\n    return head ;\n}\n\nstruct node* ContestWinner(struct node *head, int k, int n)\n{\n  /* if 1 element is only there */\n  if(n == 1)\n    return head;\n    \n  /* for storing our resultant element */\n  int res = 0;\n  \n  for(int i=1; i<=n; i++){\n    res = (res + k-1)%i + 1;\n  }\n  \n  /* finding the node of resultant element */\n  for(int i=1; i<res; i++){\n    head = head->next;\n  }\n  \n  /* marking its next node as NULL \n    and returning resultant node address */\n  head->next = NULL;\n  return head;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        struct node *head = NULL, *temp ;\n       int size, i, val, M;\n\n        scanf(\"%d %d\",&size, &M);\n\n        for ( i = 0 ; i < size ; i ++ ) {\n         scanf(\"%d\",&val);\n            head = getNode(head, val) ;\n        }\n        temp = ContestWinner(head, M, size) ;\n        if ( temp != NULL )\n            printf(\"%d\n\", temp->value) ;\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct node\n{\n int value;\n    struct node* next;\n}node;\n\nnode* getNode (node *head, int val)\n{\n    node *element = new node;\n    element->value = val ;\n    element->next = NULL ;\n    node *temp = head ;\n    if ( head == NULL ) {\n     head = element ;\n        head->next = head ;\n        return head ;\n    }\n    while (temp->next != head)\n       temp = temp->next ;\n    temp->next = element ;\n    element->next = head ;\n    return head ;\n}\n\nstruct node* ContestWinner(struct node *head, int k, int n)\n{\n  /* if 1 element is only there */\n  if(n == 1)\n    return head;\n    \n  /* for storing our resultant element */\n  int res = 0;\n  \n  for(int i=1; i<=n; i++){\n    res = (res + k-1)%i + 1;\n  }\n  \n  /* finding the node of resultant element */\n  for(int i=1; i<res; i++){\n    head = head->next;\n  }\n  \n  /* marking its next node as NULL \n    and returning resultant node address */\n  head->next = NULL;\n  return head;\n}\n\nint main() {\n    int t;\n    cin>>t;\n    while(t--){\n        node *head = NULL, *temp ;\n        int size, i, val, M;\n\n        cin>>size>>M;\n\n        for ( i = 0 ; i < size ; i ++ ) {\n           cin>>val;\n            head = getNode(head, val) ;\n        }\n        temp = ContestWinner(head, M, size) ;\n     if ( temp != NULL )\n            cout<< temp->value<<endl ;\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static class SinglyLinkedListNode {\n        public int data;\n        public SinglyLinkedListNode next;\n\n        public SinglyLinkedListNode(int nodeData) {\n            this.data = nodeData;\n            this.next = null;\n        }\n    }\n\n   static class SinglyLinkedList {\n        public SinglyLinkedListNode head;\n        public SinglyLinkedListNode tail;\n\n        public SinglyLinkedList() {\n            this.head = null;\n            this.tail = null;\n        }\n\n        public void insertNode(int nodeData) {\n            SinglyLinkedListNode node = new SinglyLinkedListNode(nodeData);\n\n            if (this.head == null) {\n                this.head = node;\n            } else {\n     this.tail.next = node;\n            }\n\n            this.tail = node;\n        }\n    }\n\n    static void printLinkedList(SinglyLinkedListNode head) {\n        SinglyLinkedListNode temp = head;\n        while (temp != null) {\n System.out.print(temp.data + \" \");\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n\n  static SinglyLinkedListNode ContestWinner(SinglyLinkedListNode head, int k, int n)\n    {\n      /* if 1 element is only there */\n      if(n == 1)\n        return head;\n        \n      /* for storing our resultant element */\n      int res = 0;\n      \n      for(int i=1; i<=n; i++){\n        res = (res + k-1)%i + 1;\n      }\n      \n /* finding the node of resultant element */\n      for(int i=1; i<res; i++){\n        head = head.next;\n      }\n \n      /* marking its next node as NULL \n        and returning resultant node address */\n      head.next = null;\n      return head;\n    }\n    private static final Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int testCases = scanner.nextInt();\n        while (testCases-- > 0) {\n            SinglyLinkedList llist = new SinglyLinkedList();\n            int size = scanner.nextInt();\n            int M = scanner.nextInt();\n            for (int i = 0; i < size; i++) {\n                int llistItem = scanner.nextInt();\n                llist.insertNode(llistItem);\n            }\n            SinglyLinkedListNode temp = ContestWinner(llist.head, M, size);\n            System.out.println(temp.data);\n        }\n    }\n}\n```\n\n#### Refer Video for *Quick Explaination* :\n[![Myself](https://img.youtube.com/vi/_y8k37Pt-tk/maxresdefault.jpg \"Contest Winner\")](https://www.youtube.com/watch?v=_y8k37Pt-tk)\n\n#### Can you guess the `Time Complexity` of the `Efficient` solution ? \n\n1. $O(logN)$  \n\n2. $O(N*logN)$\n\n3. $O(N)$\n\n4. $O(N^2)$\n\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "linklist-3",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_gd_mistakes.png",
		heading: "Arrange the Salary",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a linked list of N elements and a value X, your task is to arrange the list in such a way that all elements less than X comes first, then finally all elements greater than or equal to X.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Arrange the Salary\n\n#### CONCEPTS USED:\nBasic Pointer Manipulation\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a linked list of $N$ elements and a value $X$, your task is to arrange the list in such a way that all elements less than $X$ comes first, then finally all elements greater than or equal to $X$.\n   \n***NOTE*** :  You have to maintain the original relative order of the elements at the time of arranging the salary. \n\n#### For Example:\n\n```\nInput :  \n\nlist = 9 -> 6 -> 3 -> 7 -> 1 -> 4\nK = 5\n\nOutput: 3 -> 1 -> 4 -> 9 -> 6 -> 7\n\nExplaination : Elements smaller than 5 i.e. 3, 1, 4 are arranged at the starting while elements greater than 5 are arranged after them without changing the relative order of all the elements.\n```\n\n#### SOLVING APPROACH:\n\n#### BRUTE FORCE METHOD:\n\n1. The idea is to create two additional arrays `min_arr` and `max_arr` for storing the elements less than $X$ in `min_arr` while to store elements greater than or equal to $X$ in `max_arr`.  \n\n2. Then simply print elements from `min_arr` first and then `max_arr`.\n\n3. This approach is not `efficient` as it uses additional $O(N)$ space.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($Using C++ STL$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct Node {\n    int data;\n    struct Node *next;\n}Node;\nNode* temp = NULL;\nNode* insert(Node *head, int data) {\n    if(head == NULL) {\n        head = new Node();\n        head->data = data;\n        head->next = NULL;\n        return temp = head;\n    }\n    Node* node = new Node();\n    node->data = data;\n    node->next = NULL;\n    temp->next = node;\n    temp = temp->next;\n    return head;\n}\n\nvoid print(Node *head) {\n    if(head->next == NULL) {\n        cout << head->data << \" \";\n     return;\n    }\n    cout << head->data << \" \";\n    print(head->next);\n}\n\nNode* ArrangeSalary(Node* head, int X) {\n  \n    if(head == NULL || head->next == NULL)\n      return head;\n      \n    Node *temp = head;\n      \n vector<int> v_min, v_max;\n    while(temp != NULL){\n      if(temp->data < X)\n        v_min.push_back(temp->data);\n      else\n        v_max.push_back(temp->data);\n      temp = temp->next;\n    }\n   \n    temp = head;\n    \n while(temp != NULL){\n      if(!v_min.empty()){\n        temp->data = v_min.front();\n        v_min.erase(v_min.begin());\n      }\n      else if(!v_max.empty()){\n        temp->data = v_max.front();\n        v_max.erase(v_max.begin());\n      }\n      \n      temp = temp->next;\n    }\n    return head;\n\n}\n\nint main()\n{\n\n    Node *head = NULL;\n    Node *ptr = NULL;\n    int n, X;\n    cin >> n >>X;\n    for(int i=0; i<n; i++) {\n        int data;\n cin >> data;\n        head = insert(head, data);\n    }\n    head = ArrangeSalary(head, X);\n    print(head);\n    cout << endl;\n    return 0;\n}\n```\n\n#### EFFICIENT METHOD:\n\n>1. The idea is to create two linked list and initialize their head nodes as NULL -\n>>1. `smaller` list of values smaller than $X$.  \n>>2. `larger` list of values greater than or equal to $X$.\n>2. Now traverse the original list and if an element is less than $X$, append it to the end of the `smaller` list else append it to the end of the `larger` list. Finally concatenate both the `smaller` and `larger` lists to form the resultant list.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\ntypedef struct Node {\n    int data;\n    struct Node *next;\n}Node;\nNode* getNode (Node*head, int val)\n{\n    Node *element = (Node*) malloc(sizeof(Node));\n    element->data = val ;\n    element->next = NULL ;\n    Node *temp = head ;\n    if ( head == NULL ) {\n        head = element ;\n        head->next = NULL ;\n        return head ;\n    }\n    while (temp->next != NULL)\n        temp = temp->next ;\n    temp->next = element ;\n    element->next = NULL ;\n    return head ;\n}\n\n\nvoid print(Node *head) {\n    if(head->next == NULL) {\n        printf(\"%d \", head->data);\n        return;\n    }\n    printf(\"%d \", head->data);\n    print(head->next);\n}\n\nNode* ArrangeSalary(Node* head, int X) {\n  \n  /* if list has 0 or 1 elements then return */\n  if(head == NULL || head->next == NULL)\n    return head;\n    \n  /* create two lists one for storing smaller elements than X and\n    another for storing greater than or equal to elements than X */\n \n  /* head pointer for smaller list */\n  Node *smaller = NULL ;\n  \n  /*pointer to the last element in the smaller list */\n  Node *temp_smaller;\n  \n   /* head pointer for greater list */\n  Node *greater = NULL ;\n  \n  /*pointer to the last element in the greater list */\n  Node *temp_greater ;\n  \n  Node *temp = head;\n  \n  while(temp != NULL){\n    Node* t = temp;\n    temp = temp -> next;\n    \n    if(t->data < X){\n      if(smaller == NULL){\n        smaller = t;\n        temp_smaller = t;\n        t -> next = NULL;\n      }\n      else{\n        temp_smaller -> next = t;\n        t -> next = NULL;\n        temp_smaller = t;\n      }\n      \n    }\n    else{\n      if(greater == NULL){\n        greater = t;\n        temp_greater = t;\n        t -> next = NULL;\n      }\n      else{\n        temp_greater -> next = t;\n        t -> next = NULL;\n        temp_greater = t;\n      }\n    }\n  }\n \n  /* concatenating both smaller and greater lists */\n  temp_smaller -> next = greater;\n  \n  return smaller;\n\n}\nint main()\n{\n\n    Node *head = NULL;\n    int n, X;\n    scanf(\"%d %d\", &n,&X);\n    for(int i=0; i<n; i++) {\n        int data;\n        scanf(\"%d\", &data);\n        head = getNode(head, data);\n    }\n    head = ArrangeSalary(head, X);\n    print(head);\n    printf(\"\n\");\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct Node {\n    int data;\n    struct Node *next;\n}Node;\nNode* temp = NULL;\nNode* insert(Node *head, int data) {\n    if(head == NULL) {\n        head = new Node();\n        head->data = data;\n        head->next = NULL;\n        return temp = head;\n    }\n    Node* node = new Node();\n    node->data = data;\n    node->next = NULL;\n    temp->next = node;\n    temp = temp->next;\n    return head;\n}\n\nvoid print(Node *head) {\n    if(head->next == NULL) {\n        cout << head->data << \" \";\n        return;\n    }\n    cout << head->data << \" \";\n    print(head->next);\n}\n\nNode* ArrangeSalary(Node* head, int X) {\n  \n  /* if list has 0 or 1 elements then return */\n  if(head == NULL || head->next == NULL)\n return head;\n    \n  /* create two lists one for storing smaller elements than X and\n    another for storing greater than or equal to elements than X */\n  \n  /* head pointer for smaller list */\n  Node *smaller = NULL ;\n  \n /*pointer to the last element in the smaller list */\n  Node *temp_smaller= NULL;\n  \n   /* head pointer for greater list */\n  Node *greater = NULL ;\n  \n  /*pointer to the last element in the greater list */\n  Node *temp_greater = NULL;\n  \n  Node *temp = head;\n  \n  while(temp != NULL){\n    Node* t = temp;\n    temp = temp -> next;\n \n    if(t->data < X){\n      if(smaller == NULL){\n        smaller = t;\n        temp_smaller = t;\n        t -> next = NULL;\n      }\n      else{\n        temp_smaller -> next = t;\n        t -> next = NULL;\n        temp_smaller = t;\n      }\n      \n    }\n    else{\n      if(greater == NULL){\n        greater = t;\n        temp_greater = t;\n        t -> next = NULL;\n      }\n      else{\n        temp_greater -> next = t;\n        t -> next = NULL;\n        temp_greater = t;\n      }\n    }\n  }\n  \n  /* concatenating both smaller and greater lists */\n  temp_smaller -> next = greater;\n  \n  return smaller;\n}\n\nint main()\n{\n\n    Node *head = NULL;\n    Node *ptr = NULL;\n    int n, X;\n    cin >> n >>X;\n    for(int i=0; i<n; i++) {\n        int data;\n        cin >> data;\n     head = insert(head, data);\n    }\n    head = ArrangeSalary(head, X);\n    print(head);\n    cout << endl;\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class SinglyLinkedListNode {\n        public int value;\n        public SinglyLinkedListNode next;\n\n        public SinglyLinkedListNode(int nodeData) {\n            this.value = nodeData;\n            this.next = null;\n        }\n    }\n\n    static class SinglyLinkedList {\n        public SinglyLinkedListNode head;\n        public SinglyLinkedListNode tail;\n\n        public SinglyLinkedList() {\n            this.head = null;\n            this.tail = null;\n        }\n\n        public void insertNode(int nodeData) {\n            SinglyLinkedListNode node = new SinglyLinkedListNode(nodeData);\n\n            if (this.head == null) {\n                this.head = node;\n            } else {\n                this.tail.next = node;\n            }\n\n            this.tail = node;\n        }\n    }\n\n    static void printLinkedList(SinglyLinkedListNode head) {\n        SinglyLinkedListNode temp = head;\n        while (temp != null) {\n            System.out.print(temp.value + \" \");\n           temp = temp.next;\n        }\n        System.out.println();\n    }\n\nstatic SinglyLinkedListNode ArrangeSalary(SinglyLinkedListNode head, int X) {\n\n    /* if list has 0 or 1 elements then return */\n    if(head == null || head.next == null)\n      return head;\n      \n    /* create two lists one for storing smaller elements than X and\n   another for storing greater than or equal to elements than X */\n    \n    /* head pointer for smaller list */\n   SinglyLinkedListNode smaller = null;\n    \n    /*pointer to the last element in the smaller list */\n    SinglyLinkedListNode temp_smaller = null;\n    \n     /* head pointer for greater list */\n    SinglyLinkedListNode greater = null;\n    \n    /*pointer to the last element in the greater list */\n    SinglyLinkedListNode temp_greater = null;\n    \n    SinglyLinkedListNode temp = head;\n    \n    while(temp != null){\n      SinglyLinkedListNode t = temp;\n      temp = temp.next;\n      \n      if(t.value < X){\n        if(smaller == null){\n          smaller = t;\n          temp_smaller = t;\n          t.next = null;\n        }\n        else{\n          temp_smaller.next = t;\n          t.next = null;\n          temp_smaller = t;\n        }\n        \n      }\n      else{\n        if(greater == null){\n          greater = t;\n          temp_greater = t;\n          t.next = null;\n        }\n        else{\n          temp_greater.next = t;\n          t.next = null;\n          temp_greater = t;\n        }\n      }\n   }\n    \n    /* concatenating both smaller and greater lists */\n    temp_smaller.next = greater;\n    \n      return smaller;\n}\n\n\n    private static final Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n\n        SinglyLinkedList llist = new SinglyLinkedList();\n        int size = scanner.nextInt();\n        int X = scanner.nextInt();\n\n        for (int i = 0; i < size; i++) {\n           int llistItem = scanner.nextInt();\n\n            llist.insertNode(llistItem);\n        }\n        SinglyLinkedListNode temp = ArrangeSalary(llist.head, X);\n        printLinkedList(temp);\n\n    }\n}\n```\n\n#### Can you guess the `Time and Space Complexity` of the `Efficient` solution ? \n\n1. $O(N)$, $O(1)$\n\n2. $O(N*logN)$, $O(N)$\n\n3. $O(N)$, $O(N)$\n\n4. $O(N^2)$, $O(1)$\n\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "linklist-4",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_stress_interviews.png",
		heading: "Arrange the List",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a linked list of $N$ nodes such that the list is sorted in two parts, the first part and second part are sorted in increasing order independently. Your task is to arrange the linked list in sorted manner.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Arrange the List\n\n#### CONCEPTS USED:\nBasic Pointer Manipulation\n\n#### DIFFICULTY LEVEL:\nMedium \n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a linked list of $N$ nodes such that the list is sorted in two parts, the first part and second part are sorted in increasing order independently. Your task is to arrange the linked list in sorted manner.    \n\n#### For Example:\n\n```\nInput : 3 -> 4 -> 6 -> 7 -> 8 -> 2 -> 3 -> 4\n\nOutput : 2 -> 3 -> 3 -> 4 -> 4 -> 6 -> 7 -> 8\n\nExplanation : 3 -> 4 -> 6 -> 7 -> 8 and 2 -> 3 -> 4 were separately sorted two list which we have combined to form a single sorted list as 2 -> 3 -> 3 -> 4 -> 4 -> 6 -> 7 -> 8.\n```\n\n#### OBSERVATION :\n\nThe problem can be seen as merging two sorted linked list in-place i.e. without using any extra space.\n\n#### SOLVING APPROACH:\n\n1. We already have the `head` of our first list as the `head` of our original list, now we need to find the `head` of the second list, this can be easily done by traversing the list and checking wherever the $i^{th}$ node value becomes greater than the $(i+1)^{th}$ node value. Then $(i+1)^{th}$ node is our `head` pointer for the second list.\n\n2. Now create a new `newHead` that will point to our newly created list.\n\n3. Now Keep traversing the former two lists simultaneously, and appending the smaller node out of the two in the new list. Also increment the pointer of the smaller node to point to the next node.\n\n4. In this way all the elements from both the list will be appended to the new list. Keep doing this process till any of the list becomes empty, then append all the remaining nodes to the new list.\n\n#### ALGORITHM :\n\n```\nhead1 -> first list\nhead2 -> second list\nnewHead -> final sorted list\n\nwhile( list1 is not empty OR list2 is not empty )\n    find smaller node out of the list1 and list2\n    append this node to the new list\n    increment the pointer of the smaller node containing list by 1\n\nif ( list1 becomes empty )\n    append all elements of list2 to the new list\n\nif ( list2 becomes empty )\n append all elements of list1 to the new list\n\nreturn pointer of the new list i.e. newHead\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct Node\n{\n    int value;\n    struct Node* next;\n}Node;\n\nNode* CreateNode(Node *head, int val)\n{\n    Node *newnode = (struct Node*)malloc(sizeof(struct Node));\n    newnode->value = val ;\n    newnode->next = NULL ;\n    static Node *temp;\n    if ( head == NULL ) {\n        head = newnode ;\n        temp=head;\n    }\n    else\n {\n        temp->next = newnode ;\n        temp =temp->next;\n    }\n    return head ;\n}\n\n\nvoid printList(Node *head) {\n    Node *temp = head ;\n    if (temp) {\n        while ( temp!= NULL ) {\n            printf ( \"%d \", temp->value ) ;\n            temp = temp->next ;\n        }\n    }\n}\n\nNode* RearrangeLists(Node* head)\n{\n  /* if head contains 0 or 1 elements */\n  if(head == NULL || head->next == NULL)\n    return head;\n    \n  Node *temp = head;\n  Node *part = NULL;\n  Node *partition = NULL;\n  \n  /* findint the point of partition between two head */\n  while(temp->next != NULL){\n    if(temp->value > temp->next->value){\n      part = temp;\n      partition = temp->next;\n      break;\n    }\n    temp = temp->next;\n  }\n  \n  /* if there exits no partition */\n  if(partition == NULL)\n    return head;\n    \n  /* set last element of head 1 to point to NULL */\n  part->next = NULL;\n  \n  /* Now we have two different head */\n  \n  Node *p = head; \n  Node *q = partition;\n  \n  Node *sorting = NULL;\n  \n  if(p != NULL && q != NULL){\n    if(p->value < q->value){\n      sorting = p;\n      p = p->next;\n    }\n else{\n      sorting = q;\n      q = q->next;\n    }\n  }\n  \n  /* Head of the new linked head */\n  Node *newHead = sorting;\n  \n   while(p != NULL && q != NULL){\n    if(p->value < q->value){\n      sorting->next = p;\n      sorting = p;\n      p = p->next;\n    }\n    else{\n      sorting->next = q;\n      sorting = q;\n      q = q->next;\n    }\n  }\n  \n  if(p == NULL) sorting->next = q;\n  if(q == NULL) sorting->next = p;\n  \n  return newHead;\n}\n\n\nint main() {\n\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n\n        Node *head = NULL, *temp ;\n     int size,val;\n        scanf(\"%d\", &size);\n        for ( int i = 0 ; i < size ; i ++ ) {\n            scanf(\"%d\", &val);\n            head = CreateNode(head, val) ;\n        }\n\n        temp = RearrangeLists(head) ;\n       printList(temp);\n\n        printf(\"\n\");\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct Node\n{\n    int data;\n    struct Node* next;\n}Node;\n\nNode* CreateNode(Node *head, int val)\n{\n    Node *newnode = new Node;\n    newnode->data = val ;\n    newnode->next = NULL ;\n    static Node *temp;\n    if ( head == NULL ) {\n        head = newnode ;\n        temp=head;\n    }\n    else\n    {\n        temp->next = newnode ;\n        temp =temp->next;\n    }\n    return head ;\n}\n\nvoid printList(Node *head) {\n    Node *temp = head ;\n    if (temp) {\n        while ( temp!= NULL ) {\n            cout<<temp->data<<\" \";\n            temp = temp->next ;\n        }\n    }\n}\n\nNode* RearrangeLists(Node* list)\n{\n  if(list == NULL || list->next == NULL)\n    return list;\n    \n    Node *temp = list;\n    \n  \n    Node *part = NULL;\n    Node *partition = NULL;\n    int f = 0;\n    \n    \n    /* findint the point of partition between two list */\n    while(temp->next != NULL){\n      if(temp->data > temp->next->data){\n        part = temp;\n        partition = temp->next;\n        break;\n      }\n      temp = temp->next;\n    }\n    \n    /* if there exits no partition */\n    if(partition == NULL)\n      return list;\n      \n    /* set last element of list 1 to point to NULL */\n    part->next = NULL;\n    \n    /* Now we have two different list */\n    \n    Node *p = list; \n    Node *q = partition;\n    \n    Node *sorting = NULL;\n    \n    if(p != NULL && q != NULL){\n      if(p->data < q->data){\n        sorting = p;\n        p = p->next;\n      }\n      else{\n        sorting = q;\n       q = q->next;\n      }\n    }\n    \n    /* Head of the new linked list */\n    Node *head = sorting;\n    \n     while(p != NULL && q != NULL){\n      if(p->data < q->data){\n        sorting->next = p;\n        sorting = p;\n     p = p->next;\n      }\n      else{\n        sorting->next = q;\n        sorting = q;\n        q = q->next;\n      }\n    }\n    \n    if(p == NULL) sorting->next = q;\n    if(q == NULL) sorting->next = p;\n    \n    return head;\n}\n\n\nint main() {\n\n    int t;\n    cin>>t;\n    while(t--){\n\n        Node *head = NULL, *temp ;\n        int size,val;\n        cin>>size;\n        for ( int i = 0 ; i < size ; i ++ ) {\n            cin>>val;\n            head = CreateNode(head, val) ;\n        }\n\n        temp =RearrangeLists(head) ;\n        if ( temp != NULL )\n     printList(temp);\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    static class SinglyLinkedListNode {\n       public int value;\n        public SinglyLinkedListNode next;\n        public SinglyLinkedListNode(int nodeData) {\n this.value = nodeData;\n            this.next = null;\n        }\n    }\n    static class SinglyLinkedList {\n     public SinglyLinkedListNode head;\n        public SinglyLinkedListNode tail;\n\n        public SinglyLinkedList() {\n            this.head = null;\n            this.tail = null;\n        }\n        public void insertNode(int nodeData) {\n            SinglyLinkedListNode node = new SinglyLinkedListNode(nodeData);\n\n            if (this.head == null) {\n                this.head = node;\n            } else {\n                this.tail.next = node;\n         }\n            this.tail = node;\n        }\n    }\n\n    static void printLinkedList(SinglyLinkedListNode head) {\n        SinglyLinkedListNode temp = head;\n        while (temp != null) {\n            System.out.print(temp.value + \" \");\n            temp = temp.next;\n        }\n    }\n\n    static SinglyLinkedListNode RearrangeLists(SinglyLinkedListNode list)\n    {\n        /* if list contains 0 or 1 elements */\n        if(list == null || list.next == null)\n            return list;\n            \n        SinglyLinkedListNode temp = list;\n        SinglyLinkedListNode part = null;\n        SinglyLinkedListNode partition = null;\n        \n        /* findint the point of partition between two list */\n        while(temp.next != null){\n            if(temp.value > temp.next.value){\n       part = temp;\n            partition = temp.next;\n            break;\n            }\n            temp = temp.next;\n        }\n        \n        /* if there exits no partition */\n        if(partition == null)\n            return list;\n            \n        /* set last element of list 1 to point to null */\n        part.next = null;\n        \n        /* Now we have two different list */\n        \n        SinglyLinkedListNode p = list; \n        SinglyLinkedListNode q = partition;\n        \n        SinglyLinkedListNode sorting = null;\n        \n        if(p != null && q != null){\n            if(p.value < q.value){\n            sorting = p;\n            p = p.next;\n            }\n            else{\n            sorting = q;\n            q = q.next;\n            }\n        }\n        \n       /* Head of the new linked list */\n        SinglyLinkedListNode head = sorting;\n        \n        while(p != null && q != null){\n            if(p.value < q.value){\n            sorting.next = p;\n            sorting = p;\n       p = p.next;\n            }\n            else{\n            sorting.next = q;\n            sorting = q;\n           q = q.next;\n            }\n        }\n        \n        if(p == null) sorting.next = q;\n        if(q == null) sorting.next = p;\n        \n        return head;\n    }\n\n\n    private static final Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n\n        int testCases = scanner.nextInt();\n        while (testCases-- > 0) {\n            SinglyLinkedList llist = new SinglyLinkedList();\n         int size = scanner.nextInt();\n            for (int i = 0; i < size; i++) {\n                int val = scanner.nextInt();\n                llist.insertNode(val);\n            }\n            SinglyLinkedListNode temp = RearrangeLists(llist.head);\n            printLinkedList(temp);\n            System.out.print(\"\n\");\n        }\n    }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(logN)$  \n\n2. $O(N*logN)$\n\n3. $O(N)$\n\n4. $O(N^2)$\n\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "linklist-5",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_face_interview_freshers.jpg",
		heading: "List Reduction",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a linked list of N nodes such that each node have a lower case alphabet (a - z). Your task is to remove the nodes which have the same data and are next to each other.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# List Reduction\n\n#### CONCEPTS USED:\nLinked list\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a linked list of $N$ nodes such that each node have a lower case alphabet `(a - z)`. Your task is to remove the nodes which have the same data and are next to each other.\n\n#### For Example:\n\n```\nInput : bddbcgdghgii\n\nOutput: cgdghg\n\nExplanation : bddbcgdghgii -> bbcgdghg -> cgdghg\n```\n\n#### SOLVING APPROACH:\n\n>1. The idea is to create another list `temp` to store the reduced version of the original list. \n>\n>2. Traverse the original list and perform the following operations :-\n>>1. If the `temp` list is empty, simply append the current element into the list.  \n>>\n>>2. If the `temp` list is not empty, check if the last element inserted is equal to the current element, If `Yes` remove the last element added.  \n>>3. Else if the last element is not equal to the current element, append the current element into the list. Finally our original list will be reduced and stored in the `temp` list.\n\n\n#### ILLUSTRATION:\n\n```\nlist = bddbcgdghgii\ntemp is empty\n\nStart traversing the list :-\n\nfor 1st element b, temp is empty so append into it \ntemp = b\n\nfor 2nd element d, b is not equal to d so append into it\ntemp = bd\n\nfor 3rd element d, d is equal to d so remove already added d\ntemp = b\n\nfor 4th element b, b is equal to b so remove already added b, temp becomes empty now\ntemp = \n\nfor 5th element c, temp is empty so append into it\ntemp = c\n\nfor 6th element g, g is not equal to c so append into it\ntemp = cg\n\nfor 7th element d, d is not equal to g so append into it\ntemp = cgd\n\nfor 8th element g, g is not equal to d so append into it\ntemp = cgdg\n\nfor 9th element h, h is not equal to g so append into it\ntemp = cgdgh\n\nfor 10th element g, g is not equal to h so append into it\ntemp = cgdghg\n\nfor 11th element i, i is not equal to g so append into it\ntemp = cgdghgi\n\nfor 12th element i, i is equal to i so remove already added i\ntemp = cgdghg\n\nSo, our final reduced list is cgdghg\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct Node {\n    char value;\n    struct Node *next;\n}Node;\n\nNode* CreateNode(Node *head, char val)\n{\n    Node *newnode = (struct Node*)malloc(sizeof(struct Node));\n    newnode->value = val ;\n    newnode->next = NULL ;\n    if ( head == NULL ) {\n        head = newnode ;\n    }\n    else\n    {\n        newnode->next=head;\n        head=newnode;\n    }\n    return head ;\n}\n\nvoid printList(Node *head) {\n Node *temp = head ;\n    if (temp) {\n        while ( temp!= NULL ) {\n            printf ( \"%c\", temp->value ) ;\n            temp = temp->next ;\n        }\n    }\n}\n\nNode* ListDestruction(Node *Head)\n{\n    \n    Node *head = NULL,*t=Head;\n    while(t!=NULL)\n     {\n        char ch=t->value;\n        \n        if(head == NULL)\n     head = CreateNode(head, ch);\n        else {\n            if(head->value == ch) {\n                Node *temp = head;\n                head = head->next;\n                free(temp);\n            }\n            else {\n           head = CreateNode(head,ch);\n            }\n        }\n        t=t->next;\n    }\n    \n    return head;\n\n}\n\nint main()\n{\n    struct  Node *head = NULL ;\n    int size, i;\n    char val[100005];\n    scanf(\"%d\", &size);\n scanf(\" %s\", val);\n\n\n    for ( i = 0 ; i < size ; i ++ ) {\n        char ch=val[i];\n        head = CreateNode(head, ch) ;\n    }\n\n    head = ListDestruction(head);\n    if(head!=NULL)\n        printList(head);\n    else\n printf(\"-1\");\n\n\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    char data;\n    struct Node *next;\n};\n\nNode *insert( Node *head, char ch) {\n    Node *node = new Node();\n    if(head==NULL) {\n        head = new Node();\n        head->data = ch;\n        return head;\n    }\n    node->data = ch;\n    node->next = head;\n    return node;\n}\n\nvoid PrintList(Node *head)\n{\n    if(head == NULL)\n        return;\n    while(head!=NULL){\n        cout<<head->data;\n        head=head->next;\n    }\n}\n\nNode* ListDestruction(Node *Head)\n{\n    \n    Node *head = NULL,*t=Head;\n    while(t!=NULL)\n     {\n        char ch=t->data;\n        \n        if(head == NULL)\n            head = insert( head,ch);\n        else {\n            if(head->data == ch) {\n                Node *temp = head;\n                head = head->next;\n                free(temp);\n            }\n            else {\n                head = insert(head,ch);\n            }\n        }\n        t=t->next;\n    }\n    \n    return head;\n\n}\n\nint main()\n{\n    struct  Node *head = NULL, *temp ;\n    int size, i;\n    string val;\n    cin>>size;\n    cin>>val;\n    for ( i = 0 ; i < size ; i ++ ) {\n        char ch=val[i];\n        head = insert(head, ch) ;\n    }\n    temp=ListDestruction(head);\n    if(temp!=NULL)\n        PrintList(temp);\n    else\n        cout<<-1;\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main\n{\n    static class SinglyLinkedListNode {\n        char value;\n        SinglyLinkedListNode next;\n        SinglyLinkedListNode(char nodeData) {\n           this.value = nodeData;\n           this.next = null;\n       }\n   }\n    static class SinglyLinkedList {\n        public SinglyLinkedListNode head;\n        public SinglyLinkedListNode tail;\n\n        public SinglyLinkedList() {\n            this.head = null;\n            this.tail = null;\n        }\n\n        public void insertNode( char nodeData) {\n            SinglyLinkedListNode node = new SinglyLinkedListNode(nodeData);\n\n if (this.head == null) {\n                this.head = node;\n                this.tail=node;\n\n            } else {\n                SinglyLinkedListNode temp=this.head;\n                this.head=node;\n                this.head.next =temp;\n            }\n        }\n    }\n    static void printLinkedList( SinglyLinkedListNode head)\n    {\n SinglyLinkedListNode temp=head;\n        while(temp!=null)\n        {\n            System.out.print(temp.value);\n temp=temp.next;\n        }\n    }\n   \n    static SinglyLinkedList ListDestruction(SinglyLinkedList list)\n       {\n            SinglyLinkedList temp = new SinglyLinkedList();\n            SinglyLinkedListNode current = list.head; \n            SinglyLinkedListNode prev = null;\n\n          while (current != null)\n          {\n             if (temp.head == null || temp.head.value != current.value) {\n                    temp.insertNode(current.value);\n } else {\n                    temp.head = temp.head.next;\n                }\n\n                current = current.next; \n          }\n          return temp;\n        }\n\n    private static Scanner scanner = new Scanner(System.in);\n    public static void main( String[] args) throws IOException {\n\n        SinglyLinkedList llist = new SinglyLinkedList();\n        int size = scanner.nextInt();\n        scanner.nextLine();\n        String val = scanner.next();\n\n        for (int i = 0; i < size; i++) {\n            char ch = val.charAt(i);\n\n                llist.insertNode(ch);\n            }\n         SinglyLinkedList ans = ListDestruction(llist);\n         if (ans.head == null) {\n             System.out.println(\"-1\");\n         } else {\n            printLinkedList(ans.head);\n         }\n    }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(N*logN)$\n\n3. $O(N)$\n\n4. $O(N^2)$\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, for creating an `Additional linked list`."
	},
	{
		id: "recursion-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_face_interview_freshers.jpg",
		heading: "Mike and Binary Number",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given a number N, your task is to print all possible permutations of its Binary Representation.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Mike and Binary Number\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a number $N$, your task is to print all possible permutations of its `Binary Representation`.\n\n***NOTE*** : Print the output in the lexicographically sorted form.\n\n#### For Example :\n\n```\nInput : N = 5\n\nOutput : 011 101 110\n\nExplanation : \n\nBinary Representation of 5 is 101 and all permutations of it i.e. 011 101 110 are printed in a lexicographic order.\n```\n\n#### SOLVING APPROACH:\n\n1. Start by finding the number of zeros and ones present in the `Binary Representation` of $N$ and store them in `ones` and `zeros`.   \n\n2. Initialize an empty string `str` for storing all such combinations one-by-one.\n\n3. If `ones` = 0, append all the `zeros` to `str` and print it. Else if `zeros` = 0, append all `ones` to `str` and print it.\n\n4. Else recursively keep appending a $0$ to `str` and reduce `zeros` by $1$. Similarly recursively keep appending a $1$ to `str` and reduce `ones` by $1$ till all `zeros` and `ones` are appended in the `str` and its size becomes equal to size of the `Binary Representation` of the number $N$.\n\n#### ILLUSTRATION :\n\n```\nN = 5 \nBinary Representation of 5 = 101\nZeros = 1\nOnes = 2\nstr = \"\"\n\nSince Zeros and Ones both are not 0, append 0 to str and reduce Zeros by 1\nstr = \"0\"\nZeros = 0\n\nSince Zeros = 0, append all remaining 1's to str\nstr = \"011\"\nOnes = 0\n\nSince Zeros = Ones = 0\nprint the str i.e. our first valid permutation of Binary Representation of 5.\n\nSimilarly print all such permutations recursively.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* function for finding all such combinations */\nvoid permutation(int no_ones, int no_zeroes, string accum,vector<string>&perm){\n   if(no_ones == 0){\n       for(int i=0;i<no_zeroes;i++){\n     accum += \"0\";\n       }\n       perm.push_back(accum);\n       return;\n   }\n   else if(no_zeroes == 0){\n       for(int j=0;j<no_ones;j++){\n           accum += \"1\";\n       }\n       perm.push_back(accum);\n       return;\n }\n\n   permutation (no_ones - 1, no_zeroes, accum + \"1\",perm);\n   permutation (no_ones , no_zeroes - 1, accum + \"0\",perm);\n}\n\nint main(){\n   int t;\n   cin>>t;\n   while(t--){\n   int n, ones = 0, zeros = 0;\n   cin>>n;\n \n   /* finding number of zeros and ones in the number */\n   while(n>0)\n   {\n       if(n&1)\n           ones++;\n       else\n        zeros++;\n      n =n>>1;    \n   }\n   \n   //initializing an empty string\n   string append = \"\";\n   \n   //vector of strings to store all the combinations \n   vector<string>perm;\n     \n    \n   permutation(ones, zeros, append, perm);  \n   \n   /* sort all combinations in ascending order */\n   sort(perm.begin(),perm.end());\n   \n   for(int i=0;i<perm.size();i++)\n     cout<<perm[i]<<\" \";\n   }\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  \n   /* function for finding all such combinations */\n  static void permutation(int no_ones, int no_zeroes, String accum, ArrayList<String> perm){\n     if(no_ones == 0){\n         for(int i=0;i<no_zeroes;i++){\n             accum += \"0\";\n     }\n         perm.add(accum);\n         return;\n     }\n     else if(no_zeroes == 0){\n         for(int j=0;j<no_ones;j++){\n             accum += \"1\";\n         }\n         perm.add(accum);\n         return;\n     }\n  \n     permutation (no_ones - 1, no_zeroes, accum + \"1\",perm);\n     permutation (no_ones , no_zeroes - 1, accum + \"0\",perm);\n  }\n\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n  \n    while(t != 0){\n    int n = sc.nextInt();\n    int ones = 0, zeros = 0;\n    \n    /* finding number of zeros and ones in the number */\n    while(n>0)\n    {\n       if(n%2 == 0)\n   zeros++;\n       else\n          ones++;\n      n /= 2;    \n    }\n    \n    //initializing an empty string\n    String append = \"\";\n    \n    //vector of strings to store all the combinations \n    //vector<string>perm;\n    ArrayList<String> perm = new ArrayList<String>(); \n     \n    \n    permutation(ones, zeros, append, perm);  \n   \n    /* sort all combinations in ascending order */\n    Collections.sort(perm);\n    \n    for(int i=0;i<perm.size();i++)\n      System.out.print(perm.get(i) + \" \");\n    System.out.println();\n    \n    t--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ? \n\n1. $O(N^2)$  \n\n2. $O(2^N)$\n\n3. $O(N*2^N)$\n\n4. $O(N^2 * 2^N)$\n \n**Time Complexity**: $O(N*2^N)$\n"
	},
	{
		id: "recursion-2",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_handle_interview_nervousness.png",
		heading: "Check Palindrome",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given a number N, check whether the number is palindrome or not using recursion. The palindrome number remains the same when its digits are reversed.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Check Palindrome\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a number $N$, check whether the number is palindrome or not using recursion. The palindrome number remains the same when its digits are reversed.\n\n#### For Example :\n\n```\nInput : N = \"12321\"\n\nOutput : YES\n```\n\n```\nInput : N = \"123\"\n\nOutput : NO \n\nExplanation : 123 is not equal to 321\n```\n\n#### SOLVING APPROACH:\n\n>1. Find `reverse` of a number -\n>>* Initialise `result` with 0.  \n>>\n>>* Whenever value of $N$ becomes $0$, return `result`.\n>>* If $N$ is not $0$, update `result` with `result` * $10$ $+$ $N$%$10$.\n>>* And recursively solve for $N/10$.\n>2. Compare `reverse` with $N$ if both are equal, print YES else NO.\n\n#### ALGORITHM:\n\n```\nresult = 0\nsolve(N) :\n    if(N becomes 0)\n        return result\n    else \n        res = res * 10 + N %10\n        solve(N/10)\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\n//function for finding reverse of a number\nint isPalin(int n,int res){\n  if(n == 0)\n    return res;\n  \n  res = res*10 + n%10;\n  return isPalin(n/10,res);\n}\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--){\n   int n;\n    scanf(\"%d\",&n);\n    int rev = isPalin(n,0);\n    if(n == rev)\n      printf(\"YES\n\");\n    else\n printf(\"NO\n\");\n    \n}\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//function for finding reverse of a number\nint isPalin(int n,int res){\n  if(n == 0)\n    return res;\n  \n  res = res*10 + n%10;\n  return isPalin(n/10,res);\n}\n\nint main()\n{\n  int t;cin>>t;\n  while(t--){\n    int n;cin>>n;\n    int rev = isPalin(n,0);\n    if(n == rev)\n      cout<<\"YES\n\";\n    else\n      cout<<\"NO\n\";\n    \n}\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  //function for finding reverse of a number\n  static int isPalin(int n,int res){\n    if(n == 0)\n      return res;\n    \n    res = res*10 + n%10;\n    return isPalin(n/10,res);\n  }\n\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t != 0){\n      int n = sc.nextInt();\n      int res = 0;\n      int rev = isPalin(n,res);\n      if(n == rev)\n        System.out.println(\"YES\");\n      else\n        System.out.println(\"NO\");\n      t--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ? \n1. $O(N)$  \n\n2. $O(log_{2}N)$\n\n3. $O(log_{10}N)$\n\n4. $O(Nlog_{10}N)$\n\n\n**Time Complexity**: $O(log_{10}N)$, as $N$ is divided by $10$ in each step."
	},
	{
		id: "recursion-3",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_introduce_yourself.png",
		heading: "First Capital Using Recursion",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given a String T, find the 1'st occurrence of the capital (uppercase) alphabet. Print its index if present, else -1.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# First Capital Using Recursion\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a String $T$, find the $1^{st}$ occurrence of the capital (`uppercase`) alphabet. Print its index if present, else $-1$. \n\n#### For Example:\n\n```\nInput : T = prepBytes\n\nOutput : 4\n```\n\n```\nInput : T = helloWorld\n\nOutput : 5\n```\n\n***Can we use `Recursion` here ?***\nYes, the problem can be divided into sub problems, for example $T$ $=$ \"prepBytes\", check if first character is `Upper Case`. If Yes print index else search in the remaining string.\n\n#### SOLVING APPROACH:\n\n1. Create a function with three parameters a `string`, `start` index,  `end` index.  \n\n2. Base conditions form the `Backbone` of recursion, so if `start` becomes greater than `end`, simply return $-1$.\n\n3. Because this implies entire string has been traversed but no `upper case` letter was found.\n\n4. If the Ascii value of current char is greater than or equal to $65$ and less than or equal to $90$, this means an `upper case` letter is found, simply return this `index` value.\n\n#### ALGORITHM:\n\n```\nIsUpperCase(string, i, j)\n\n  if (entire string is traversed or i becomes greater than j)\n    return -1\n\n if (character at ith index is upper case)\n    return i\n  else\n    return IsUpperCase(string, i+1, j)\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint first_upper(char s[],int i){\n  if(s[i] == '\\0')                   //base condition\n    return -1;\n  if(s[i] >= 65 && s[i] <=90)\n    return i;\n  else\n    return first_upper(s,i+1);\n}\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  while(n--){\n    char s[100000];\n    scanf(\"%s\",s);\n    printf(\"%d\n\",first_upper(s,0));\n  \n  }\n  return 0; \n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n```cpp\n #include <bits/stdc++.h>\nusing namespace std;\n\nint first_upper(string s,int first,int last){\n  \n  if(first>last)       //base condition\n    return -1;\n  if(s[first] >= 65 && s[first] <= 90)\n    return first;\n  else\n    return first_upper(s,first+1,last);\n}\nint main()\n{\n  int n;cin>>n;\n while(n--){\n    string s;cin>>s;\n    int first = 0;\n    int last = s.size()-1;\n    cout<<first_upper(s,first,last)<<\"\n\";\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  \n  static int first_upper(String s,int first){\n  if(first >= s.length())          //base condition\n    return -1;\n  if (Character.isUpperCase(s.charAt(first)))  \n      return first;\n else\n    return first_upper(s,first+1);\n  }\n\n  public static void main(String args[]) throws IOException {\n   \n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    while(n!=0){\n      String s = sc.next();\n      int first = 0;\n      System.out.println(first_upper(s,first));\n      n--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ?\n\n1. $O(N)$  \n\n2. $O(N^2)$\n\n3. $O(N*logN)$\n\n4. $O(2^N)$\n\nTime Complexity: $O(N)$\n"
	},
	{
		id: "recursion-4",
		img: "https://img.youtube.com/vi/pa8YkGUWyR0/maxresdefault.jpg",
		heading: "Matrix and combination",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given a matrix M*N containing only lowercase english alphabets, your task is to select elements from the first row one by one, and print all the possible combinations downwards.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Matrix and combination\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a matrix $M$*$N$ containing only lowercase english alphabets, your task is to select elements from the first row one by one, and print all the possible combinations downwards.   \n \n**Conditions for making Combinations**: \n\n* $Rule1-$ Every combination starts from the first row of the matrix and proceeds downwards. He may switch columns though.    \n\n* $Rule2-$ Every combination should have characters equal to the number of rows.  \n* $Rule3-$ A combination can't have an element from the same row present twice.\n\n#### For Example :\n\n```\nInput : [ [a, b],\n          [c, d],\n          [e, f] ]\n\nOutput : ace acf ade adf bce bcf bde bdf\n\nExplanation : \n\nConsider all combinations that start from a -\nace, acf, ade, adf\nConsider all combinations that start from b -\nbce, bcf, bde, bdf\n```\n\n***Can we use `Recursion` here ?***\nYes, as the problem demands to print all the possible combinations. We can use `Recursion` to find all such combinations.\n\n#### SOLVING APPROACH:\n\n1. Initialize an empty string `Str` to store our resultant output.  \n\n2. Start traversing each and every row recursively by incrementing the value of `curr row` by $1$ and keep appending the current character in the `Str`, when we reach the last row, print `Str` and return, as there are no values to process further.\n\n3. Similarly all combinations of first row elements will be generated by following $step$ $2$, $N$ number of times in a loop.\n\n#### Refer video for *Quick Explaination*:\n[![Myself](https://img.youtube.com/vi/pa8YkGUWyR0/maxresdefault.jpg \"Wealthy Father\")](https://www.youtube.com/watch?v=pa8YkGUWyR0)\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid matrixAndComb(vector<vector<char>> v, int i, int m, int n, string str){\n  \n  if(i == m){\n    cout<<str<<\" \";\n    return ;\n  }\n  \n  for(int j=0; j<n; j++)\n    matrixAndComb(v, i+1, m, n, str + v[i][j]);\n}\n\nint main()\n{\n  int m,n; cin>>m>>n;\n   vector<vector<char> > v( m , vector<char> (n));\n  for(int i=0; i<m; i++){\n    for(int j=0; j<n; j++)\n      cin>>v[i][j];\n  }\n  string str = \"\";\n  matrixAndComb(v , 0, m, n, str);\n\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  static void matrixAndComb(char [][]arr, int i, int m, int n, String str){\n  \n    /* if rows end print the string */\n    if(i == m){\n      System.out.print(str + \" \");\n      return ;\n    }\n    for(int j=0; j<n; j++){\n      \n      matrixAndComb(arr, i+1, m, n, str + arr[i][j]);\n    }\n  }\n  \n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n    char arr[][] = new char[m][n];\n for(int i=0; i<m; i++){\n      for(int j=0; j<n; j++)\n        arr[i][j] = sc.next().charAt(0);\n    }\n    String str = \"\";\n    matrixAndComb(arr , 0, m, n, str);\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ?\n\n1. $O(N^M)$  \n\n2. $O(M^N)$\n\n3. $O(N*M)$\n\n4. $O(2^{N+M})$\n\n**Time Complexity**: $O(N^M)$"
	},
	{
		id: "recursion-5",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/start_preparation_blog.jpg",
		heading: "Mike and Exam",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given an array containing N elements and an integer K, find the number of ways to calculate the value of K using array elements.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Mike and Exam\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array containing $N$ elements and an integer $K$, find the number of ways to calculate the value of $K$ using array elements.\n\n**NOTE**:\n1. The array contains both $(-ve)$ and $(+ve)$ integers.  \n\n2. Use only `Addition` and `Subtraction` to accomplish the task.\n\n#### For Example :\n\n```\nInput : \n\nN = 4, K = 2\nA = [1 3 2 6] \n\nOutput : 5\n\nExplanation : All combinations that give 2 as output are - \n\n1st : +(2) = 2\n\n2nd : -(1) - (3) + (6) = 2\n\n3rd : -(1) + (3) = 2\n\n4th : +(1) - (2) + (3) = 2\n\n5th : +(1) - (2) - (3) + (6) = 2\n```\n\n#### SOLVING APPROACH:\n\n>1. The idea is to start processing array elements from $(i=0)$ to $(i=N-1)$, with $K$ as the required value.  \n>\n>2. Check if at any point the value of $i$ becomes $(>= N)$ and the required value of $K$ is not equal to $0$, simply return $0$. \n>3. Else recursively check for the three possible cases :- \n>> 1. Consider current element and add it to $K$ (`Addition Operation`)  \n>>\n>>2. Consider current element and subtract it from $K$ (`Subtaction Operation`) \n>>3. Don't consider the current element.\n>4. At any point if the value of $K$ becomes $0$, return 1. \n>\n>4. Finally return the total `count` of the three cases.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint findTotalWays(int arr[],int n,int i,int k){\n  /* If all elements are processed and \n   target is not reached, return 0 */\n  if(i >= n && k != 0 )\n    return 0;\n \n  // If target is reached, return 1 \n  if(k == 0)\n    return 1;\n  \n  /* Return total count of three cases \n 1. Don't consider current element \n     2. Consider current element and subtract it from target \n     3. Consider current element and add it to target */\n  return  findTotalWays(arr,n,i+1,k) \n        + findTotalWays(arr,n,i+1,k+arr[i])\n        +findTotalWays(arr,n,i+1,k-arr[i]);\n}\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    int sum = 0;\n    for(int i=0;i<n;i++){\n     scanf(\"%d\",&arr[i]);\n    }\n    printf(\"%d\n\",findTotalWays(arr,n,0,k));\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findTotalWays(int arr[],int n,int i,int k){\n  /* If all elements are processed and \n     target is not reached, return 0 */\n  if(i >= n && k != 0 )\n    return 0;\n  \n  // If target is reached, return 1 \n  if(k == 0)\n    return 1;\n  \n  /* Return total count of three cases \n     1. Don't consider current element \n     2. Consider current element and subtract it from target \n     3. Consider current element and add it to target */\n  return  findTotalWays(arr,n,i+1,k) \n        + findTotalWays(arr,n,i+1,k+arr[i])\n        +findTotalWays(arr,n,i+1,k-arr[i]);\n}\n\nint main()\n{\n  int t;cin>>t;\n  while(t--){\n    int n,k;cin>>n>>k;\n    int arr[n];\n    int sum = 0;\n    for(int i=0;i<n;i++){\n cin>>arr[i];\n    }\n    cout<<findTotalWays(arr,n,0,k)<<\"\n\";\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  static int findTotalWays(int arr[],int n,int i,int k){\n    /* If all elements are processed and \n       target is not reached, return 0 */\n    if(i >= n && k != 0 )\n      return 0;\n    \n    // If target is reached, return 1 \n    if(k == 0)\n   return 1;\n    \n    /* Return total count of three cases \n       1. Don't consider current element \n       2. Consider current element and subtract it from target \n       3. Consider current element and add it to target */  \n return  findTotalWays(arr,n,i+1,k) \n          + findTotalWays(arr,n,i+1,k+arr[i])\n          +findTotalWays(arr,n,i+1,k-arr[i]);\n  }\n  public static void main(String args[]) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0){\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n int arr[] = new int[n];\n      int sum = 0;\n      for(int i=0;i<n;i++){\n        arr[i] = sc.nextInt();\n      }\n System.out.println(findTotalWays(arr,n,0,k));\n      t--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ?\n\n1. $O(2^N)$  \n\n2. $O(3^N)$\n\n3. $O(N^3)$\n\n4. $O(N^2)$\n \n**Time Complexity**: $O(3^N)$, as there are three possible cases. It takes `Exponential Time Complexity`."
	},
	{
		id: "searching-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/start_preparation_blog.jpg",
		heading: "Maximize The Boxes",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given chocolates of 3 types A, B, C with their frequencies f A,f B and f C, you need to pack these chocolates in a box. Maximize the number of boxes for given f A,f B and f C. Q queries will be asked.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Maximize The Boxes \n\n#### CONCEPTS USED:\nSearching, Basic Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven chocolates of $3$ types $A, B, C$ with their frequencies $f_A$,$f_B$ and $f_C$, you need to pack these chocolates in a box. Maximize the number of boxes for given $f_A$,$f_B$ and $f_C$. $Q$ queries will be asked.\n\n#### CONDITIONS:\n\n1. Box should contain exactly $3$ chocolates.  \n\n2. It should contain at least $1$ type of chocolate $A$ and $1$ type of chocolate $B$.\n\nAllowed : $(A,B,C) , (A,A,B), (A,B,B)$ \n\nNot Allowed : $(C,C,A) , (A,A,A)$ $etc$\n\n#### For Example:\n\n```\nInput : 4 2 1\n\nOutput : 2\n\nExplanation : Every box should have atleast 1 chocolate of type A and 1 chocolate of type B, so she have only arrangement possible - \n\n(A B C) => we have single C, which is used here\n(A B A) => out of two B's, last B is used here\n\nTherefore, Maximum of 2 boxes can be made.\n```\n\n```\nInput : 5 4 0\n\nOutput : 3\n\nExplanation : Every box should have at least 1 chocolate of type A and 1 chocolate of type B, so she have only arrangement possible - \n\n(A B A) => 3 A's and 3 B's left\n(A B B) => 2 A's and 1 B left\n(A A B) => all A's and B's used\n\nTherefore, Maximum of 3 boxes can be made.\n```\n\n#### SOLVING APPROACH:\n\n1. The approach is quite simple as there are only two cases to cover.  \n\n2. If `minimum` frequency between A and B is less than or equal to frequency of C, than `minimum` frequency between A and B is our answer, as Chocolate $A$ and $B$ are essential in every box so the `minimum` of these two will be the result.\n\n3. Else if `minimum` frequency between $A$ and $B$ is greater than frequency of $C$, this implies that putting only $1-1$ chocolate $A$ and chocolate $B$ are not sufficient in each box as there are insufficient chocolate $C$ for all such boxes.\n\n4. So, calculate the `Sum` of frequency of all the three boxes and divide it by $3$.\n\n5. The `minimum` between this `Sum` and `minimum` frequency between $A$ and $B$ will be our answer. \n\n#### ALGORITHM:\n\n```\nmin_f_AB = minimum of (frequency of A , frequency of B)\nSum_f_ABC = (frequency of A + frequency of B + frequency of C)/3\n\n\nif (min_f_AB <= frequency of C)\n    print min_f_AB\nelse\n    if(Sum_f_ABC < min_f_AB)\n        print Sum_f_ABC\n    else\n        print min_f_AB\n```\n\n#### ILLUSTRATION:\n\n```\n2 2 2\n\nMin of A and B <= C i.e. (2 <= 2)\nSo, Maximum boxes is Min of A and B i.e. 2\n```\n\n```\n4 2 1 \n\nMin of A and B > C i.e. (2 > 1)\nSo calculate average of all frequencies and check whether it is (< Min of A and B)\nsum = (A + B + C) / 3 = (4 + 2 + 1) / 3 = 2\nSince, sum < Min of A and B\nso sum is our Maximum number of boxes i.e. 2\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int q; scanf(\"%d\", &q);\n  while(q--){\n    int f_a, f_b, f_c, min_ab;\n    scanf(\"%d %d %d\", &f_a, &f_b, &f_c);\n    \n    // find mininum among f_a and f_b\n    if(f_a < f_b)\n      min_ab = f_a;\n    else\n      min_ab = f_b;\n   \n    // print the minimum of (f_a, f_b) and f_c \n    if(min_ab <= f_c){\n      printf(\"%d\n\", min_ab);\n    }\n    \n /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n    else{\n      int sum = (f_a + f_b + f_c)/3;\n      if(sum < min_ab)\n        printf(\"%d\n\", sum);\n      else \n        printf(\"%d\n\", min_ab);\n    }\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int q; cin>>q;\n  while(q--){\n    int f_a, f_b, f_c ;\n    cin>>f_a>>f_b>>f_c ;\n    \n    // print the minimum of (f_a, f_b) and f_c \n    if(min(f_a, f_b) <= f_c){\n      cout<<min(f_a, f_b)<<\"\n\";\n    }\n    \n    /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n    else{\n      int sum = (f_a + f_b + f_c)/3;\n      cout<<min(sum, min(f_a, f_b)) <<\"\n\";\n    }\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\nimport java.lang.Math;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int q = sc.nextInt();\n    \n    while(q != 0){\n      int f_a = sc.nextInt();\n      int f_b = sc.nextInt();\n      int f_c = sc.nextInt();\n     \n      // print the minimum of (f_a, f_b) and f_c \n      if(Math.min(f_a, f_b) <= f_c){\n        System.out.println(Math.min(f_a, f_b));\n }\n      \n      /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n     else{\n        int sum = (f_a + f_b + f_c)/3;\n        System.out.println(Math.min(sum, Math.min(f_a, f_b)));\n     }\n      q--;\n    }\n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(NlogN)$\n\n3. $O(N^2)$\n\n4. $O(N)$\n\nwhere $N =$ $Number$ $of$ $queries$\n \n**Time Complexity**: $O(N)$\n \n**Space Complexity**: $O(1)$"
	},
	{
		id: "searching-2",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_vinit_story.png",
		heading: "Get the Sun Light",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given an array A of unique heights of buildings. The sun is facing buildings from left to right, print the number of buildings facing the sun directly.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Get the Sun Light  \n\n#### CONCEPTS USED:\nSearching\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven an array $A$ of unique heights of buildings. The sun is facing buildings from left to right, print the number of buildings facing the sun directly.\n\n#### For Example :\n\n```\nInput : arr[] = [7, 4, 8, 2, 9]\n\nOutput : 3 \n\nExplanation : (7, 8 and 9) are facing sun directly while (4 and 2) are hidden after 7 and 8\n``` \n\n#### SOLVING APPROACH:\n\n1. The idea is to traverse the array from left to right and keep incrementing the `count` whenever we find the `tallest` building of the array up till now.  \n\n2. Initialise `tallest` as `-1` and `count` as `0`.\n\n3. Traverse the array and if an element is greater than `tallest` then update it as `tallest` and increment `count` by $1$.\n\n4. Finally, print the value of  `count`.\n\n#### ILLUSTRATION:\n\n```\nA[] = [7, 4, 8, 2, 9]\ncount = 0\ntallest = -1\n\ni = 0\nSince A[0] > tallest\ntallest = A[0] = 7\ncount++ => count = 1\ni++ \n\ni = 1\nSince A[1] <= tallest\ni++\n\ni = 2\nSince A[2] > tallest\ntallest = A[2] = 8\ncount++ => count = 2\ni++\n\ni = 3\nSince A[3] <= tallest\ni++\n\ni = 4\nSince A[4] > tallest \ntallest = A[4] = 9\ncount++ => count = 3\ni++\n\nSince i = 5\nstop\n\nSo total 3 buildings are facing the sun directly.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t; scanf(\"%d\", &t);\n  while(t--){\n   int n; scanf(\"%d\", &n);\n    int arr[n];\n    \n    //mark tallest building as -1 \n    int max_ele = -1, count = 0;\n    for(int i=0; i<n; i++){\n      scanf(\"%d\", &arr[i]);\n      \n    /* check if current building is taller than the tallest building\n    if Yes increment count and mark it as tallest building else skip */\n      if(arr[i] > max_ele){\n        max_ele = arr[i];\n        count++;\n      }\n    }\n    printf(\"%d\n\",count);\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t; cin>>t;\n  while(t--){\n    int n; cin>>n;\n    int arr[n];\n    \n    //mark tallest building as -1 \n    int max_ele = -1, count = 0;\n    for(int i=0; i<n; i++){\n      cin>>arr[i];\n      \n    /* check if current building is taller than the tallest building\n    if Yes increment count and mark it as tallest building else skip */\n      if(arr[i] > max_ele){\n        max_ele = arr[i];\n        count++;\n      }\n    }\n    cout<<count<<\"\n\";\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t != 0){\n      int n = sc.nextInt();\n   int arr[] = new int[n];\n      \n      //mark tallest building as -1 \n      int max_ele = -1, count = 0;\n      for(int i=0; i<n; i++){\n        arr[i] = sc.nextInt();\n        \n      /* check if current building is taller than the tallest building\n      if Yes increment count and mark it as tallest building else skip */\n        if(arr[i] > max_ele){\n          max_ele = arr[i];\n          count++;\n        }\n      }\n      System.out.println(count);\n      t--;\n    }\n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(NlogN)$\n\n3. $O(N^2)$\n\n4. $O(N)$\n\n**Time Complexity**: $O(N)$ \n\n**Space Complexity**: $O(1)$"
	},
	{
		id: "searching-3",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/non_cse_blog.jpg",
		heading: "Factorial Zeros",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given a number N, your task is to find the count of all such numbers that have N trailing zeros in their factorial.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Factorial Zeros \n\n#### CONCEPTS USED:\nBinary Search, Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven a number $N$, your task is to find the count of all such numbers that have $N$ trailing zeros in their factorial.\n\n#### For Example:\n\n```\nInput : N = 2\n\nOutput : 5\n\nExplanation : \n\nAll these 5 numbers have 2 trailing zeros.\n\n10! = 3628800\n\n11! = 39916800\n\n12! = 479001600\n\n13! = 6227020800\n\n14! = 87178291200\n```\n\n**OBSERVATION**:\n\n1. The solution of this problem will be either $0$ or $5$.  \n\n2. $0$ if no such number is found whose factorial has $N$ trailing zeros.\n\n3. $5$ because if a number has $N$ trailing zeros then its 4 neigbouring numbers will also have the same trailing zeros.    \n\n***For Example***:   \n\n`(10, 11, 12 , 13, 14)` all will have 2 trailing zeros in their factorial. Similarly   \n\n`(15, 16, 17, 18, 19)` all will have 3 trailing zeros in their factorial.  \n\nSimilary all such group of 5 numbers contain the same number of trailing zeros in their factorial.   \n\n***Important Point***:  \nWe just need to find a single number that has $N$ trailing zeros and our answer will be $5$ else $0$.\n\n***Can we use `Binary Search` here ?***  \nWe need to find a single number between $0$ and $5*N$ that has $N$ trailing zeros. We can use `Binary Search` for efficiently searching it in `Logarithmic Time Complexity`.\n\n***Why $5*N$?***\n$5*N$ is the upper bound and any number whose factorial has $N$ trailing zeros will be less than the factorial of $5*N$.\n\n#### SOLVING APPROACH:\n\n1. The idea is to use `Binary Search`.  \n\n2. Initialize `low` and `high` as $0$ and $N*5$.\n\n3. Calculate $mid = low + (high - low)/2$ and let us assume that mid is our required number with $N$ trailing zeros.\n\n4. Find `trailing-zeros-of-mid` and compare it with $N$, if both are equal return mid.\n\n5. Else if `trailing-zeros-of-mid` > $N$, this implies that our required number lies in the lower half so we update $high = mid - 1$. \n\n6. Else $($`trailing-zeros-of-mid` < $N)$ implies that our required number lies in the higher half so we update $low = mid + 1$. And keep on searching for a feasible number till $(low <= high)$, if post this condition number is not found return $0$.\n\n#### ALGORITHM:\n```\ni = 0\nj = 5 * N\nmid = (i + j) / 2 \n\nwhile i <= j\n\n  If trail_zeros_of_mid = N\n    print 5\n\n  else if trail_zeros_of_mid < N\n    i = mid + 1\n\n  else\n    j = mid - 1\n\nif i > j\n  print 0\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#define ll long long\n\n/* funtion for finding trailing zeroes in a number */\nll TrailingZeroUtil(ll n){\n    ll sum = 0;\n    ll five = 5;\n    while(n >= five){\n        sum += n/five;\n        five *= 5;\n    }\n  return sum;\n}\n\n/* function for searching that number whose \n  number of trailing zeros is equal to n */\nll TrailingZeros(ll n, ll low, ll high){\n  while(low <= high){\n    ll mid = low + (high - low)/2;\n    \n    //finding trailing zeros of mid \n    ll trailing_zeros = TrailingZeroUtil(mid);\n    \n    //checking if mid is our required number\n    if(trailing_zeros == n)\n      return mid;\n    \n    /* if mid has greater trailing zeros than required\n        we go on searching in the lower half */\n    else if(trailing_zeros > n)\n      high = mid - 1; \n    \n    /* if mid has lesser trailing zeros than required\n        we go on searching in the righter half */\n    else\n      low = mid + 1;\n  }\n  //if no number has trailing zeros equal to n return 0\n  return 0;\n}\n\nint main()\n{\n  int t; scanf(\"%lld\", &t);\n  while(t--){\n ll n; scanf(\"%lld\", &n);\n    ll low = 0; \n    ll high = n*5;\n    \n    //find the required number with trailing zeros equal to n\n    ll ans = TrailingZeros(n, low, high);\n    \n    //if no number found with n trailing zeros print 0\n    if(ans == 0)\n      printf(\"0\n\");\n    \n    /* if a number is found with n trailing zeros then \n even 4 numbers ahead of the number will have the \n    same number of trailing zeros therefore print 5 */\n    else\n      printf(\"5\n\");\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\n/* funtion for finding trailing zeroes in a number */\nll TrailingZeroUtil(ll n){\n    ll sum = 0;\n    ll five = 5;\n    while(n >= five){\n        sum += n/five;\n       five *= 5;\n    }\n  return sum;\n}\n\n/* function for searching that number whose \n  number of trailing zeros is equal to n */\nll TrailingZeros(ll n, ll low, ll high){\n  while(low <= high){\n    ll mid = low + (high - low)/2;\n    \n    //finding trailing zeros of mid \n    ll trailing_zeros = TrailingZeroUtil(mid);\n    \n    //checking if mid is our required number\n    if(trailing_zeros == n)\n      return mid;\n    \n    /* if mid has greater trailing zeros than required\n        we go on searching in the lower half */\n    else if(trailing_zeros > n)\n      high = mid - 1; \n    \n    /* if mid has lesser trailing zeros than required\n        we go on searching in the righter half */\n    else\n      low = mid + 1;\n  }\n  //if no number has trailing zeros equal to n return 0\n  return 0;\n}\n\nint main()\n{\n  int t; cin>>t;\n  while(t--){\n    ll n; cin>>n;\n    ll low = 0; \n    ll high = n*5;\n \n    //find the required number with trailing zeros equal to n\n    ll ans = TrailingZeros(n, low, high);\n    \n //if no number found with n trailing zeros print 0\n    if(ans == 0)\n      cout<<0<<\"\n\";\n    \n    /* if a number is found with n trailing zeros then \n    even 4 numbers ahead of the number will have the \n    same number of trailing zeros therefore print 5 */\n    else\n      cout<<5<<\"\n\";\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  static long TrailingZeroUtil(long n){\n      long sum = 0;\n      long five = 5;\n      while(n >= five){\n          sum += n/five;\n          five *= 5;\n      }\n    return sum;\n  }\n\n/* function for searching that number whose \n  number of trailing zeros is equal to n */\nstatic long TrailingZeros(long n, long low, long high){\n    while(low <= high){\n long mid = low + (high - low)/2;\n      \n      //finding trailing zeros of mid \n      long trailing_zeros = TrailingZeroUtil(mid);\n      \n      //checking if mid is our required number\n      if(trailing_zeros == n)\n        return mid;\n      \n      /* if mid has greater trailing zeros than required\n          we go on searching in the lower half */\n      else if(trailing_zeros > n)\n        high = mid - 1; \n      \n      /* if mid has lesser trailing zeros than required\n          we go on searching in the righter half */\n      else\n        low = mid + 1;\n }\n    //if no number has trailing zeros equal to n return 0\n    return 0;\n  }\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t != 0){\n      long n = sc.nextInt();\n      long low = 0; \n      long high = n*5;\n      \n      //find the required number with trailing zeros equal to n\n      long ans = TrailingZeros(n, low, high);\n      \n      //if no number found with n trailing zeros print 0\n      if(ans == 0)\n        System.out.println(\"0\");\n      \n      /* if a number is found with n trailing zeros then \n      even 4 numbers ahead of the number will have the \n      same number of trailing zeros therefore print 5 */\n      else\n        System.out.println(\"5\");\n      t--;\n    }\n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(Nlog_5N)$  \n\n2. $O(Nlog_2N*log_5N)$\n\n3. $O(Nlog_2N)$\n\n4. $O(log_2N*log_5N)$\n \n**Time Complexity**: $O(log_2N*log_5N)$, $log_2N$ for `Binary Search` and $log_5N$ for finding trailing zeros in a number. \n \n**Space Complexity**: $O(1)$"
	},
	{
		id: "searching-4",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_hr_interview_qualities.png",
		heading: "Floor of a number",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given a sorted array A and a number x. find the largest value in the array that is less than or equal to x and print its index.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Floor of a number   \n\n#### CONCEPTS USED:\nSearching\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven a sorted array $A$ and a number $x$. find the largest value in the array that is less than or equal to $x$ and print its index. \n\n#### For Example:\n\n```\nInput :  N = 7, x = 5\n        A[] = [1, 2, 8, 10, 11, 12, 19]\n\nOutput : 1 (as 2 <= 5 and it is present on index 1)\n```\n\n***Can we use `Binary Search` here ?***  \nGiven that the array is sorted, `Binary Search` would be an efficient alternative to quickly search for the element that is less than or equal to $x$ in `Logarithmic Time Complexity`.\n\n#### SOLVING APPROACH:\n\n1. The idea is to use `Binary Search`.  \n\n2. Check if $x$ is less than the first element of the array, if Yes return -1.\n\n3. Check if $x$ is greater than the last element of the array, if Yes return the `index` of the last element as it is going to be its floor value.\n\n4. Else, the floor value will be present in the array.\n\n5. Take out the `mid` index of the array by $mid = (start + end)/2$.\n\n6. Check if value at `mid` matches $x$, if Yes return its index.\n\n7. Else if value at `mid` $< x$, this implies that the floor value lies at the right half.\n\n8. Else (value at `mid` $> x$) , this implies that the floor value lies at the left half.\n\n9. Recursively go on searching for the floor value, if `step` $5$ becomes true, return index. Else return the `end` value.\n\n#### ALGORITHM:\n\n```\nif (x is less than first element of the array)\n    print -1\nelse if (x is greater than last element of the array)\n    print last element index\nelse\n    Search in array\n    \n\nSearch in array\n    mid = (first + last)/2\n    if (element at mid index = x)\n        print mid \n    else if (element at mid index < x)\n        Search in right half of the array with first = mid + 1\n    else\n        Search in left half of the array with last = mid - 1\nprint last\n```\n\n#### ILLUSTRATION:\n\n```\nA[] = [1, 2, 8, 10, 11, 12, 19]\nx = 5\n\ni = 0\nj = 6\nmid = (0 + 6) / 2 = 3\nSince A[3] > x\nj = mid - 1 = 2\n\ni = 0\nj = 2\nmid = (0 + 2) / 2 = 1\nSince A[1] < x\ni = mid + 1 = 1 + 1 = 2\n\ni = 2\nj = 2\nmid = (2 + 2) / 2 = 2\nSince A[2] > x\nj = mid - 1 = 2 - 1 = 1\n\nSince, i > j, we will stop here and print index j i.e. 1\nas A[1] i.e. 2 is less than or equal to x.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint floor_number(int arr[], int low, int high, int x){\n  if(low <= high){\n    int mid = (low + high)/2;\n    \n    //If x matches a element in the array, return its index\n    if(arr[mid] == x)\n      return mid;\n    \n    //if x > mid value of array, search in the right half \n    else if(arr[mid] < x)\n      return floor_number(arr, mid+1, high, x);\n      \n    //if x < mid value of array, search in the left half\n    else\n      return floor_number(arr, low, mid-1, x);\n  }\n  //If no value matches x , return high\n return high;\n}\nint main()\n{\n  int t; scanf(\"%d\",&t);\n  while(t--){\n    int n, x; scanf(\"%d %d\", &n, &x);\n    int arr[n];\n    int low = 0, high = n-1;\n    \n    for(int i=0; i<n; i++)\n      scanf(\"%d\", &arr[i]);\n   \n    //If x is smaller than the first element print -1\n    if(x < arr[0])\n      printf(\"-1\n\");\n    \n    /* If x is greater than the last element,\n      its floor value will be the last element */\n    else if(x > arr[n-1])\n      printf(\"%d\n\",n-1);\n    else\n    //Floor value is present in the array, check for it\n      printf(\"%d\n\", floor_number(arr, low, high, x));\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint floor_number(int arr[], int low, int high, int x){\n  if(low <= high){\n    int mid = (low + high)/2;\n    \n    //If x matches a element in the array, return its index\n   if(arr[mid] == x)\n      return mid;\n    \n    //if x > mid value of array, search in the right half \n    else if(arr[mid] < x)\n      return floor_number(arr, mid+1, high, x);\n      \n    //if x < mid value of array, search in the left half\n    else\n      return floor_number(arr, low, mid-1, x);\n  }\n  //If no value matches x , return high\n  return high;\n}\nint main()\n{\n  int t; cin>>t;\n  while(t--){\n    int n, x; cin>>n>>x;\n    int arr[n];\n int low = 0, high = n-1;\n    \n    for(int i=0; i<n; i++)\n      cin>>arr[i];\n    \n    //If x is smaller than the first element print -1\n    if(x < arr[0])\n      cout<<-1<<endl;\n    \n    /* If x is greater than the last element,\n      its floor value will be the last element */\n    else if(x > arr[n-1])\n      cout<<n-1<<endl;\n    else\n    //Floor value is present in the array, check for it\n      cout<<floor_number(arr, low, high, x)<<endl;\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  static int floor_number(int arr[], int low, int high, int x){\n    if(low <= high){\n     int mid = (low + high)/2;\n      \n      //If x matches a element in the array, return its index\n      if(arr[mid] == x)\n        return mid;\n      \n      //if x > mid value of array, search in the right half \n      else if(arr[mid] < x)\n        return floor_number(arr, mid+1, high, x);\n        \n      //if x < mid value of array, search in the left half\n      else\n        return floor_number(arr, low, mid-1, x);\n  }\n  //If no value matches x , return high\n  return high;\n}\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t != 0){\n      int n = sc.nextInt();\n      int x = sc.nextInt();\n      int arr[] = new int[n];\n      int low = 0, high = n-1;\n      \n      for(int i=0; i<n; i++)\n        arr[i] = sc.nextInt();\n      \n      //If x is smaller than the first element print -1\n      if(x < arr[0])\n        System.out.println(\"-1\");\n      \n      /* If x is greater than the last element,\n        its floor value will be the last element */\n      else if(x > arr[n-1])\n        System.out.println(n-1);\n      else\n   //Floor value is present in the array, check for it\n        System.out.println(floor_number(arr, low, high, x));\n t--;\n    }  \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(log_2N)$  \n\n2. $O(NlogN)$\n\n3. $O(N)$\n\n4. $O(log_{10}N)$\n \n**Time Complexity**: $O(log_2N)$"
	},
	{
		id: "searching-5",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_hr_interview_qualities.png",
		heading: "Magical Ropes",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given an array H of lengths of Magical Ropes and array R of the rate by which rope increases daily, print the minimum number of days required to collect ropes that sum up to length X",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Magical Ropes\n\n#### CONCEPTS USED:\nBinary Search\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven an array $H$ of lengths of `Magical` Ropes and array $R$ of the rate by which rope increases daily, print the minimum number of days required to collect ropes that sum up to length $X$ \n\n**Restrictions**:\n1. You cannot cut the rope, you have to take complete rope for collecting it.  \n\n2. You cannot take a rope with $length$ less than $K$.\n\n#### For Example:\n\n```\nInput : N = 4, X = 100, K = 45\n        Heights[] = [2, 5, 2, 6]\n           Rate[] = [10, 13, 15, 12]\nOutput : 4\n\nExplanation :\n\nDay 0 = [2, 5, 2, 6]\n\nDay 1 = [2 + 10, 5 + 13, 2 + 15, 6 + 12]         = [12, 18, 17, 18]\n\nDay 2 = [12 + 10, 18 + 13, 17 + 15, 18 + 12]     = [22, 31, 32, 30]\n\nDay 3 = [22 + 10, 31 + 13, 32 + 15, 30 + 12]     = [32, 44, 47, 42]\n\nDay 4 = [32 + 10, 44 + 13, 47 + 15, 42 + 12]     = [42, 57, 62, 54]\n\nAns : Day 4 as (57, 62, 54 are all greater than 45 and sum up to value that is greater than equal to 100)\n```\n***Can we use `Binary Search` here ?***  \n> We need to find the minimum days required to collect ropes that sum up to length `X`. The required day can be any day between $0$ to $10^{18}$. We can use `Binary Search` for finding the right day efficiently in `Logarithmic Time Complexity`.\n\n#### SOLVING APPROACH:\n\n**NOTE**: As the length of rope is increasing by a given pace so we can calculate its length at any particular day by :-  \n\n`Lenght at ith day = ith day * Rate of Growth + Initial length`\n\n1. The idea is to perform a `Binary Search` such that whenever we find a $day$ in which ropes length sum up to $X$, we will save it and search for a even lower value (as `Minimum days` are needed).  \n\n2. initialize `low` as $0$ and `high` as $10^{18}$, by this we understand that minimum days can be as low as value of `low` and as high as value of `high`.\n\n3. Calculate  $mid = (low + high)/2$, say $mid$ is our desired day.\n\n4. Now, Linearly traverse and check for all ropes if their length at $mid$ day is greater than or equal to $K$, if Yes add its value to a variable `Sum`.\n\n5. After traversal if `Sum` becomes greater or equal to $X$, simply save it, and check for a even lower value in the left half i.e. $(low - (mid - 1))$.\n\n6. Else, search in the right half i.e. $((mid + 1) - high)$.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#define ll long long\n\nint main()\n{\n  ll N, X, K; scanf(\"%lld %lld %lld\", &N, &X, &K);\n  ll height[N], rate[N];\n  \n  //input heights of ropes\n  for(ll i=0; i<N; i++)\n    scanf(\"%lld\", &height[i]);\n    \n  //input rate of growth of ropes\n  for(ll i=0; i<N; i++)\n    scanf(\"%lld\", &rate[i]);\n    \n  //initialize minimum and maximum days that can be possible as low and high\n  ll low = 0;\n  ll high = 1000000000000000000;\n  ll min_days = 0;\n  \n  //Check for a mid value if it is satisfying the conditions\n while(low <= high){\n    ll mid = (low + high)/2;\n    ll sum = 0, flag = 0;\n    for(ll i=0 ;i<N; i++){\n      if(K <= (mid*rate[i] + height[i])){\n        sum += (mid*rate[i] + height[i]);\n        if(sum >= X){\n          flag = 1;\n          break;\n        }\n      }\n    }\n    \n    /* if mid is one of the possible day, save it and \n   keep on checking for more lower values in the left half */\n    if(flag == 1){\n      min_days = mid;\n      high = mid - 1;\n    }\n    /* if mid is not a possible day skip it and \n      go on searching in the right half */ \n   else\n      low = mid + 1;\n  }\n  printf(\"%lld\", min_days);\n    \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint main()\n{\n  ll N, X, K; cin>>N>>X>>K;\n  ll height[N], rate[N];\n  \n  //input heights of ropes\n  for(ll i=0; i<N; i++)\n    cin>>height[i];\n    \n  //input rate of growth of ropes\n  for(ll i=0; i<N; i++)\n    cin>>rate[i];\n    \n  //initialize minimum and maximum days that can be possible as low and high\n  ll low = 0;\n  ll high = 1000000000000000000;\n  ll min_days = 0;\n  \n  //Check for a mid value if it is satisfying the conditions\n  while(low <= high){\n   ll mid = (low + high)/2;\n    ll sum = 0, flag = 0;\n    for(ll i=0 ;i<N; i++){\n      if(K <= (mid*rate[i] + height[i])){\n        sum += (mid*rate[i] + height[i]);\n        if(sum >= X){\n          flag = 1;\n          break;\n }\n      }\n    }\n    \n    /* if mid is one of the possible day, save it and \n    keep on checking for more lower values in the left half */\n    if(flag == 1){\n      min_days = mid;\n      high = mid - 1;\n    }\n    /* if mid is not a possible day skip it and \n      go on searching in the right half */ \n    else\n      low = mid + 1;\n }\n  cout<<min_days;\n    \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main {\n    public static void main(String args[]){\n   \n      Scanner sc = new Scanner(System.in);\n      long N = sc.nextLong();\n      long X = sc.nextLong();\n      long K = sc.nextLong();\n      \n      long height[] = new long[(int)N];\n      long rate[] = new long[(int)N];\n   \n      //input heights of ropes\n      for(int i=0; i<N; i++)\n        height[i] = sc.nextLong();\n        \n     //input rate of growth of ropes\n      for(int i=0; i<N; i++)\n        rate[i] = sc.nextLong();\n        \n      //initialize minimum and maximum days that can be possible as low and high\n      long low = 0;\n      long high = 1000000000000000000L;\n      long min_days = 0;\n      \n      //Check for a mid value if it is satisfying the conditions\n      while(low <= high){\n        long mid = (low + high)/2;\n        long sum = 0, flag = 0;\n        for(int i=0 ;i<N; i++){\n          if(K <= (mid*rate[i] + height[i])){\n            sum += (mid*rate[i] + height[i]);\n if(sum >= X){\n              flag = 1;\n              break;\n            }\n          }\n        }\n        \n     /* if mid is one of the possible day, save it and \n        keep on checking for more lower values in the left half */\n        if(flag == 1){\n          min_days = mid;\n          high = mid - 1;\n        }\n        /* if mid is not a possible day skip it and \n          go on searching in the right half */ \n        else\n          low = mid + 1;\n      }\n      System.out.print(min_days);  \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(NlogN)$\n\n3. $O(N^2)$\n\n4. $O(N)$\n \n**Time Complexity**: $O(NlogN)$, $logN$ for the `Binary Search` and $N$ for the `Linear Search` inside.\n\n**Space Complexity**: $O(1)$"
	}
]