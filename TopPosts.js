module.exports = [
	{
		id: "array-4",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_coding_mistakes.jpg",
		heading: "Benchmates",
		category: "Array",
		date: "August 21 2019",
		desc: "Given marks of N students sitting on a bench and a value of K, print the index of the student whose marks matches with the value of K.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Benchmates\n\n#### CONCEPTS USED:\nEfficient Array Search \n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven marks of $N$ students sitting on a bench and a value of $K$, print the index of the student whose marks matches with the value of $K$. \n\n#### For Example: \n```\nInput : N = 10, K = 67\n        A[] = [60, 61, 62, 63, 63, 64, 65, 66, 67, 66]\n\nOutput : 8\n\nExplanation : 67 is present at 8th index (0-based indexing)\n```\n\n#### SOLVING APPROACH:\n\n#### BRUTEFORCE METHOD\n\n1. Linearly traverse the array, if the value of $K$ matches with any element, print its `index value` else print `-1`.   \n\n2. `Time Complexity` of this solution is $O(N)$.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    int arr[n];\n    int flag=0;\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    for(int i=0;i<n;i++)\n    {\n      if(arr[i]==k)\n      {\n        printf(\"%d\n\",i);\n        flag=1;\n        break;\n      }\n    }\n    if(flag==0)\n      printf(\"-1\n\");\n    \n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n int arr[n];\n    int flag=0;\n    for(int i=0;i<n;i++)\n      cin>>arr[i];\n    for(int i=0;i<n;i++)\n    {\n      if(arr[i]==k)\n      {\n        cout<<i<<\"\n\";\n        flag=1;\n        break;\n      }\n    }\n    if(flag==0)\n      cout<<\"-1\n\";\n  }\n  return 0;\n}\n```\n \nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$\n\n#### EFFICIENT METHOD:\n\n1. The idea is to use the property that every element is obtained either by adding $1$ or $-1$ to the previous element. Let the element to be searched is $X$.   \n\n2. Check if the value at starting index $(i=0)$ matches with $X$, if `Yes` return $i$ else there is a possibility of $X$ being present at $(i + abs(A[i] - X))$ index so  increment $i$ with $abs(A[i] - X)$.\n\n3. Keep incrementing value of $i$, if $X$ is found return $i$ else return $-1$.\n\n4. This is an `Efficient Approach` and works better than the `Naive Solution`.\n\n#### ILLUSTRATION:\n\n```\nA[] = [60, 61, 62, 63, 63, 64, 65, 66, 67, 66]\nK = 67\ni = 0\n\nA[0] != K\ni = i + abs(A[0] - K) = 0 + (60 - 67) = 7\n\nA[7] != K \ni = i + abs(A[7] - X) = 7 + (66 - 67) = 7 + 1 = 8\n\nA[8] = K\nHence we found our K at index = 8.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d%d\",&n,&k);\n    int arr[n];\n   int flag=0;\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    \n    int i = 0;\n    while(i<=n-1)\n    {\n      if(arr[i]==k)\n      {\n        printf(\"%d\n\",i);\n        break;\n      }\n      else\n        i += abs(arr[i]-k);\n    }\n    if(i>n-1)\n    {\n      printf(\"-1\n\");\n    }\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n    int flag=0;\n    for(int i=0;i<n;i++)\n     cin>>arr[i];\n    \n    int i = 0;\n    while(i<=n-1)\n    {\n      if(arr[i]==k)\n      {\n        cout<<i<<\"\n\";\n        break;\n      }\n      else\n        i += abs(arr[i]-k);\n    }\n    if(i>n-1)\n    {\n      cout<<\"-1\n\";\n    }\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0)\n    {\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      int flag=0;\n      for(int i=0;i<n;i++)\n arr[i] = sc.nextInt();\n      for(int i=0;i<n;i++)\n      {\n        if(arr[i]==k)\n        {\n          System.out.println(i);\n          flag=1;\n          break;\n        }\n      }\n      if(flag==0)\n        System.out.println(\"-1\");\n      t--;\n    }\n    \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of this solution ? \n1. $O(sqrt(N))$  \n\n2. $O(logN)$\n\n3. $O(NlogN)$\n\n4. $O(N)$\n\nTime Complexity: $O(N)$, in `Worst Case` else it will always work better than the `Naive Approach`.\n\nSpace Complexity: $O(1)$\n\n"
	},
	{
		id: "linklist-4",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_stress_interviews.png",
		heading: "Arrange the List",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a linked list of $N$ nodes such that the list is sorted in two parts, the first part and second part are sorted in increasing order independently. Your task is to arrange the linked list in sorted manner.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Arrange the List\n\n#### CONCEPTS USED:\nBasic Pointer Manipulation\n\n#### DIFFICULTY LEVEL:\nMedium \n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a linked list of $N$ nodes such that the list is sorted in two parts, the first part and second part are sorted in increasing order independently. Your task is to arrange the linked list in sorted manner.    \n\n#### For Example:\n\n```\nInput : 3 -> 4 -> 6 -> 7 -> 8 -> 2 -> 3 -> 4\n\nOutput : 2 -> 3 -> 3 -> 4 -> 4 -> 6 -> 7 -> 8\n\nExplanation : 3 -> 4 -> 6 -> 7 -> 8 and 2 -> 3 -> 4 were separately sorted two list which we have combined to form a single sorted list as 2 -> 3 -> 3 -> 4 -> 4 -> 6 -> 7 -> 8.\n```\n\n#### OBSERVATION :\n\nThe problem can be seen as merging two sorted linked list in-place i.e. without using any extra space.\n\n#### SOLVING APPROACH:\n\n1. We already have the `head` of our first list as the `head` of our original list, now we need to find the `head` of the second list, this can be easily done by traversing the list and checking wherever the $i^{th}$ node value becomes greater than the $(i+1)^{th}$ node value. Then $(i+1)^{th}$ node is our `head` pointer for the second list.\n\n2. Now create a new `newHead` that will point to our newly created list.\n\n3. Now Keep traversing the former two lists simultaneously, and appending the smaller node out of the two in the new list. Also increment the pointer of the smaller node to point to the next node.\n\n4. In this way all the elements from both the list will be appended to the new list. Keep doing this process till any of the list becomes empty, then append all the remaining nodes to the new list.\n\n#### ALGORITHM :\n\n```\nhead1 -> first list\nhead2 -> second list\nnewHead -> final sorted list\n\nwhile( list1 is not empty OR list2 is not empty )\n    find smaller node out of the list1 and list2\n    append this node to the new list\n    increment the pointer of the smaller node containing list by 1\n\nif ( list1 becomes empty )\n    append all elements of list2 to the new list\n\nif ( list2 becomes empty )\n append all elements of list1 to the new list\n\nreturn pointer of the new list i.e. newHead\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct Node\n{\n    int value;\n    struct Node* next;\n}Node;\n\nNode* CreateNode(Node *head, int val)\n{\n    Node *newnode = (struct Node*)malloc(sizeof(struct Node));\n    newnode->value = val ;\n    newnode->next = NULL ;\n    static Node *temp;\n    if ( head == NULL ) {\n        head = newnode ;\n        temp=head;\n    }\n    else\n {\n        temp->next = newnode ;\n        temp =temp->next;\n    }\n    return head ;\n}\n\n\nvoid printList(Node *head) {\n    Node *temp = head ;\n    if (temp) {\n        while ( temp!= NULL ) {\n            printf ( \"%d \", temp->value ) ;\n            temp = temp->next ;\n        }\n    }\n}\n\nNode* RearrangeLists(Node* head)\n{\n  /* if head contains 0 or 1 elements */\n  if(head == NULL || head->next == NULL)\n    return head;\n    \n  Node *temp = head;\n  Node *part = NULL;\n  Node *partition = NULL;\n  \n  /* findint the point of partition between two head */\n  while(temp->next != NULL){\n    if(temp->value > temp->next->value){\n      part = temp;\n      partition = temp->next;\n      break;\n    }\n    temp = temp->next;\n  }\n  \n  /* if there exits no partition */\n  if(partition == NULL)\n    return head;\n    \n  /* set last element of head 1 to point to NULL */\n  part->next = NULL;\n  \n  /* Now we have two different head */\n  \n  Node *p = head; \n  Node *q = partition;\n  \n  Node *sorting = NULL;\n  \n  if(p != NULL && q != NULL){\n    if(p->value < q->value){\n      sorting = p;\n      p = p->next;\n    }\n else{\n      sorting = q;\n      q = q->next;\n    }\n  }\n  \n  /* Head of the new linked head */\n  Node *newHead = sorting;\n  \n   while(p != NULL && q != NULL){\n    if(p->value < q->value){\n      sorting->next = p;\n      sorting = p;\n      p = p->next;\n    }\n    else{\n      sorting->next = q;\n      sorting = q;\n      q = q->next;\n    }\n  }\n  \n  if(p == NULL) sorting->next = q;\n  if(q == NULL) sorting->next = p;\n  \n  return newHead;\n}\n\n\nint main() {\n\n    int t;\n    scanf(\"%d\", &t);\n    while(t--){\n\n        Node *head = NULL, *temp ;\n     int size,val;\n        scanf(\"%d\", &size);\n        for ( int i = 0 ; i < size ; i ++ ) {\n            scanf(\"%d\", &val);\n            head = CreateNode(head, val) ;\n        }\n\n        temp = RearrangeLists(head) ;\n       printList(temp);\n\n        printf(\"\n\");\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct Node\n{\n    int data;\n    struct Node* next;\n}Node;\n\nNode* CreateNode(Node *head, int val)\n{\n    Node *newnode = new Node;\n    newnode->data = val ;\n    newnode->next = NULL ;\n    static Node *temp;\n    if ( head == NULL ) {\n        head = newnode ;\n        temp=head;\n    }\n    else\n    {\n        temp->next = newnode ;\n        temp =temp->next;\n    }\n    return head ;\n}\n\nvoid printList(Node *head) {\n    Node *temp = head ;\n    if (temp) {\n        while ( temp!= NULL ) {\n            cout<<temp->data<<\" \";\n            temp = temp->next ;\n        }\n    }\n}\n\nNode* RearrangeLists(Node* list)\n{\n  if(list == NULL || list->next == NULL)\n    return list;\n    \n    Node *temp = list;\n    \n  \n    Node *part = NULL;\n    Node *partition = NULL;\n    int f = 0;\n    \n    \n    /* findint the point of partition between two list */\n    while(temp->next != NULL){\n      if(temp->data > temp->next->data){\n        part = temp;\n        partition = temp->next;\n        break;\n      }\n      temp = temp->next;\n    }\n    \n    /* if there exits no partition */\n    if(partition == NULL)\n      return list;\n      \n    /* set last element of list 1 to point to NULL */\n    part->next = NULL;\n    \n    /* Now we have two different list */\n    \n    Node *p = list; \n    Node *q = partition;\n    \n    Node *sorting = NULL;\n    \n    if(p != NULL && q != NULL){\n      if(p->data < q->data){\n        sorting = p;\n        p = p->next;\n      }\n      else{\n        sorting = q;\n       q = q->next;\n      }\n    }\n    \n    /* Head of the new linked list */\n    Node *head = sorting;\n    \n     while(p != NULL && q != NULL){\n      if(p->data < q->data){\n        sorting->next = p;\n        sorting = p;\n     p = p->next;\n      }\n      else{\n        sorting->next = q;\n        sorting = q;\n        q = q->next;\n      }\n    }\n    \n    if(p == NULL) sorting->next = q;\n    if(q == NULL) sorting->next = p;\n    \n    return head;\n}\n\n\nint main() {\n\n    int t;\n    cin>>t;\n    while(t--){\n\n        Node *head = NULL, *temp ;\n        int size,val;\n        cin>>size;\n        for ( int i = 0 ; i < size ; i ++ ) {\n            cin>>val;\n            head = CreateNode(head, val) ;\n        }\n\n        temp =RearrangeLists(head) ;\n        if ( temp != NULL )\n     printList(temp);\n        cout<<endl;\n    }\n    return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.io.*;\nimport java.util.*;\npublic class Main {\n    static class SinglyLinkedListNode {\n       public int value;\n        public SinglyLinkedListNode next;\n        public SinglyLinkedListNode(int nodeData) {\n this.value = nodeData;\n            this.next = null;\n        }\n    }\n    static class SinglyLinkedList {\n     public SinglyLinkedListNode head;\n        public SinglyLinkedListNode tail;\n\n        public SinglyLinkedList() {\n            this.head = null;\n            this.tail = null;\n        }\n        public void insertNode(int nodeData) {\n            SinglyLinkedListNode node = new SinglyLinkedListNode(nodeData);\n\n            if (this.head == null) {\n                this.head = node;\n            } else {\n                this.tail.next = node;\n         }\n            this.tail = node;\n        }\n    }\n\n    static void printLinkedList(SinglyLinkedListNode head) {\n        SinglyLinkedListNode temp = head;\n        while (temp != null) {\n            System.out.print(temp.value + \" \");\n            temp = temp.next;\n        }\n    }\n\n    static SinglyLinkedListNode RearrangeLists(SinglyLinkedListNode list)\n    {\n        /* if list contains 0 or 1 elements */\n        if(list == null || list.next == null)\n            return list;\n            \n        SinglyLinkedListNode temp = list;\n        SinglyLinkedListNode part = null;\n        SinglyLinkedListNode partition = null;\n        \n        /* findint the point of partition between two list */\n        while(temp.next != null){\n            if(temp.value > temp.next.value){\n       part = temp;\n            partition = temp.next;\n            break;\n            }\n            temp = temp.next;\n        }\n        \n        /* if there exits no partition */\n        if(partition == null)\n            return list;\n            \n        /* set last element of list 1 to point to null */\n        part.next = null;\n        \n        /* Now we have two different list */\n        \n        SinglyLinkedListNode p = list; \n        SinglyLinkedListNode q = partition;\n        \n        SinglyLinkedListNode sorting = null;\n        \n        if(p != null && q != null){\n            if(p.value < q.value){\n            sorting = p;\n            p = p.next;\n            }\n            else{\n            sorting = q;\n            q = q.next;\n            }\n        }\n        \n       /* Head of the new linked list */\n        SinglyLinkedListNode head = sorting;\n        \n        while(p != null && q != null){\n            if(p.value < q.value){\n            sorting.next = p;\n            sorting = p;\n       p = p.next;\n            }\n            else{\n            sorting.next = q;\n            sorting = q;\n           q = q.next;\n            }\n        }\n        \n        if(p == null) sorting.next = q;\n        if(q == null) sorting.next = p;\n        \n        return head;\n    }\n\n\n    private static final Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n\n        int testCases = scanner.nextInt();\n        while (testCases-- > 0) {\n            SinglyLinkedList llist = new SinglyLinkedList();\n         int size = scanner.nextInt();\n            for (int i = 0; i < size; i++) {\n                int val = scanner.nextInt();\n                llist.insertNode(val);\n            }\n            SinglyLinkedListNode temp = RearrangeLists(llist.head);\n            printLinkedList(temp);\n            System.out.print(\"\n\");\n        }\n    }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(logN)$  \n\n2. $O(N*logN)$\n\n3. $O(N)$\n\n4. $O(N^2)$\n\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "recursion-5",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/start_preparation_blog.jpg",
		heading: "Mike and Exam",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given an array containing N elements and an integer K, find the number of ways to calculate the value of K using array elements.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Mike and Exam\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array containing $N$ elements and an integer $K$, find the number of ways to calculate the value of $K$ using array elements.\n\n**NOTE**:\n1. The array contains both $(-ve)$ and $(+ve)$ integers.  \n\n2. Use only `Addition` and `Subtraction` to accomplish the task.\n\n#### For Example :\n\n```\nInput : \n\nN = 4, K = 2\nA = [1 3 2 6] \n\nOutput : 5\n\nExplanation : All combinations that give 2 as output are - \n\n1st : +(2) = 2\n\n2nd : -(1) - (3) + (6) = 2\n\n3rd : -(1) + (3) = 2\n\n4th : +(1) - (2) + (3) = 2\n\n5th : +(1) - (2) - (3) + (6) = 2\n```\n\n#### SOLVING APPROACH:\n\n>1. The idea is to start processing array elements from $(i=0)$ to $(i=N-1)$, with $K$ as the required value.  \n>\n>2. Check if at any point the value of $i$ becomes $(>= N)$ and the required value of $K$ is not equal to $0$, simply return $0$. \n>3. Else recursively check for the three possible cases :- \n>> 1. Consider current element and add it to $K$ (`Addition Operation`)  \n>>\n>>2. Consider current element and subtract it from $K$ (`Subtaction Operation`) \n>>3. Don't consider the current element.\n>4. At any point if the value of $K$ becomes $0$, return 1. \n>\n>4. Finally return the total `count` of the three cases.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint findTotalWays(int arr[],int n,int i,int k){\n  /* If all elements are processed and \n   target is not reached, return 0 */\n  if(i >= n && k != 0 )\n    return 0;\n \n  // If target is reached, return 1 \n  if(k == 0)\n    return 1;\n  \n  /* Return total count of three cases \n 1. Don't consider current element \n     2. Consider current element and subtract it from target \n     3. Consider current element and add it to target */\n  return  findTotalWays(arr,n,i+1,k) \n        + findTotalWays(arr,n,i+1,k+arr[i])\n        +findTotalWays(arr,n,i+1,k-arr[i]);\n}\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--){\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    int sum = 0;\n    for(int i=0;i<n;i++){\n     scanf(\"%d\",&arr[i]);\n    }\n    printf(\"%d\n\",findTotalWays(arr,n,0,k));\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint findTotalWays(int arr[],int n,int i,int k){\n  /* If all elements are processed and \n     target is not reached, return 0 */\n  if(i >= n && k != 0 )\n    return 0;\n  \n  // If target is reached, return 1 \n  if(k == 0)\n    return 1;\n  \n  /* Return total count of three cases \n     1. Don't consider current element \n     2. Consider current element and subtract it from target \n     3. Consider current element and add it to target */\n  return  findTotalWays(arr,n,i+1,k) \n        + findTotalWays(arr,n,i+1,k+arr[i])\n        +findTotalWays(arr,n,i+1,k-arr[i]);\n}\n\nint main()\n{\n  int t;cin>>t;\n  while(t--){\n    int n,k;cin>>n>>k;\n    int arr[n];\n    int sum = 0;\n    for(int i=0;i<n;i++){\n cin>>arr[i];\n    }\n    cout<<findTotalWays(arr,n,0,k)<<\"\n\";\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  static int findTotalWays(int arr[],int n,int i,int k){\n    /* If all elements are processed and \n       target is not reached, return 0 */\n    if(i >= n && k != 0 )\n      return 0;\n    \n    // If target is reached, return 1 \n    if(k == 0)\n   return 1;\n    \n    /* Return total count of three cases \n       1. Don't consider current element \n       2. Consider current element and subtract it from target \n       3. Consider current element and add it to target */  \n return  findTotalWays(arr,n,i+1,k) \n          + findTotalWays(arr,n,i+1,k+arr[i])\n          +findTotalWays(arr,n,i+1,k-arr[i]);\n  }\n  public static void main(String args[]) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0){\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n int arr[] = new int[n];\n      int sum = 0;\n      for(int i=0;i<n;i++){\n        arr[i] = sc.nextInt();\n      }\n System.out.println(findTotalWays(arr,n,0,k));\n      t--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ?\n\n1. $O(2^N)$  \n\n2. $O(3^N)$\n\n3. $O(N^3)$\n\n4. $O(N^2)$\n \n**Time Complexity**: $O(3^N)$, as there are three possible cases. It takes `Exponential Time Complexity`."
	},
	{
		id: "searching-4",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_hr_interview_qualities.png",
		heading: "Floor of a number",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given a sorted array A and a number x. find the largest value in the array that is less than or equal to x and print its index.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Floor of a number   \n\n#### CONCEPTS USED:\nSearching\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven a sorted array $A$ and a number $x$. find the largest value in the array that is less than or equal to $x$ and print its index. \n\n#### For Example:\n\n```\nInput :  N = 7, x = 5\n        A[] = [1, 2, 8, 10, 11, 12, 19]\n\nOutput : 1 (as 2 <= 5 and it is present on index 1)\n```\n\n***Can we use `Binary Search` here ?***  \nGiven that the array is sorted, `Binary Search` would be an efficient alternative to quickly search for the element that is less than or equal to $x$ in `Logarithmic Time Complexity`.\n\n#### SOLVING APPROACH:\n\n1. The idea is to use `Binary Search`.  \n\n2. Check if $x$ is less than the first element of the array, if Yes return -1.\n\n3. Check if $x$ is greater than the last element of the array, if Yes return the `index` of the last element as it is going to be its floor value.\n\n4. Else, the floor value will be present in the array.\n\n5. Take out the `mid` index of the array by $mid = (start + end)/2$.\n\n6. Check if value at `mid` matches $x$, if Yes return its index.\n\n7. Else if value at `mid` $< x$, this implies that the floor value lies at the right half.\n\n8. Else (value at `mid` $> x$) , this implies that the floor value lies at the left half.\n\n9. Recursively go on searching for the floor value, if `step` $5$ becomes true, return index. Else return the `end` value.\n\n#### ALGORITHM:\n\n```\nif (x is less than first element of the array)\n    print -1\nelse if (x is greater than last element of the array)\n    print last element index\nelse\n    Search in array\n    \n\nSearch in array\n    mid = (first + last)/2\n    if (element at mid index = x)\n        print mid \n    else if (element at mid index < x)\n        Search in right half of the array with first = mid + 1\n    else\n        Search in left half of the array with last = mid - 1\nprint last\n```\n\n#### ILLUSTRATION:\n\n```\nA[] = [1, 2, 8, 10, 11, 12, 19]\nx = 5\n\ni = 0\nj = 6\nmid = (0 + 6) / 2 = 3\nSince A[3] > x\nj = mid - 1 = 2\n\ni = 0\nj = 2\nmid = (0 + 2) / 2 = 1\nSince A[1] < x\ni = mid + 1 = 1 + 1 = 2\n\ni = 2\nj = 2\nmid = (2 + 2) / 2 = 2\nSince A[2] > x\nj = mid - 1 = 2 - 1 = 1\n\nSince, i > j, we will stop here and print index j i.e. 1\nas A[1] i.e. 2 is less than or equal to x.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint floor_number(int arr[], int low, int high, int x){\n  if(low <= high){\n    int mid = (low + high)/2;\n    \n    //If x matches a element in the array, return its index\n    if(arr[mid] == x)\n      return mid;\n    \n    //if x > mid value of array, search in the right half \n    else if(arr[mid] < x)\n      return floor_number(arr, mid+1, high, x);\n      \n    //if x < mid value of array, search in the left half\n    else\n      return floor_number(arr, low, mid-1, x);\n  }\n  //If no value matches x , return high\n return high;\n}\nint main()\n{\n  int t; scanf(\"%d\",&t);\n  while(t--){\n    int n, x; scanf(\"%d %d\", &n, &x);\n    int arr[n];\n    int low = 0, high = n-1;\n    \n    for(int i=0; i<n; i++)\n      scanf(\"%d\", &arr[i]);\n   \n    //If x is smaller than the first element print -1\n    if(x < arr[0])\n      printf(\"-1\n\");\n    \n    /* If x is greater than the last element,\n      its floor value will be the last element */\n    else if(x > arr[n-1])\n      printf(\"%d\n\",n-1);\n    else\n    //Floor value is present in the array, check for it\n      printf(\"%d\n\", floor_number(arr, low, high, x));\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint floor_number(int arr[], int low, int high, int x){\n  if(low <= high){\n    int mid = (low + high)/2;\n    \n    //If x matches a element in the array, return its index\n   if(arr[mid] == x)\n      return mid;\n    \n    //if x > mid value of array, search in the right half \n    else if(arr[mid] < x)\n      return floor_number(arr, mid+1, high, x);\n      \n    //if x < mid value of array, search in the left half\n    else\n      return floor_number(arr, low, mid-1, x);\n  }\n  //If no value matches x , return high\n  return high;\n}\nint main()\n{\n  int t; cin>>t;\n  while(t--){\n    int n, x; cin>>n>>x;\n    int arr[n];\n int low = 0, high = n-1;\n    \n    for(int i=0; i<n; i++)\n      cin>>arr[i];\n    \n    //If x is smaller than the first element print -1\n    if(x < arr[0])\n      cout<<-1<<endl;\n    \n    /* If x is greater than the last element,\n      its floor value will be the last element */\n    else if(x > arr[n-1])\n      cout<<n-1<<endl;\n    else\n    //Floor value is present in the array, check for it\n      cout<<floor_number(arr, low, high, x)<<endl;\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  static int floor_number(int arr[], int low, int high, int x){\n    if(low <= high){\n     int mid = (low + high)/2;\n      \n      //If x matches a element in the array, return its index\n      if(arr[mid] == x)\n        return mid;\n      \n      //if x > mid value of array, search in the right half \n      else if(arr[mid] < x)\n        return floor_number(arr, mid+1, high, x);\n        \n      //if x < mid value of array, search in the left half\n      else\n        return floor_number(arr, low, mid-1, x);\n  }\n  //If no value matches x , return high\n  return high;\n}\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t != 0){\n      int n = sc.nextInt();\n      int x = sc.nextInt();\n      int arr[] = new int[n];\n      int low = 0, high = n-1;\n      \n      for(int i=0; i<n; i++)\n        arr[i] = sc.nextInt();\n      \n      //If x is smaller than the first element print -1\n      if(x < arr[0])\n        System.out.println(\"-1\");\n      \n      /* If x is greater than the last element,\n        its floor value will be the last element */\n      else if(x > arr[n-1])\n        System.out.println(n-1);\n      else\n   //Floor value is present in the array, check for it\n        System.out.println(floor_number(arr, low, high, x));\n t--;\n    }  \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(log_2N)$  \n\n2. $O(NlogN)$\n\n3. $O(N)$\n\n4. $O(log_{10}N)$\n \n**Time Complexity**: $O(log_2N)$"
	},
	{
		id: "searching-5",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_hr_interview_qualities.png",
		heading: "Magical Ropes",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given an array H of lengths of Magical Ropes and array R of the rate by which rope increases daily, print the minimum number of days required to collect ropes that sum up to length X",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Magical Ropes\n\n#### CONCEPTS USED:\nBinary Search\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven an array $H$ of lengths of `Magical` Ropes and array $R$ of the rate by which rope increases daily, print the minimum number of days required to collect ropes that sum up to length $X$ \n\n**Restrictions**:\n1. You cannot cut the rope, you have to take complete rope for collecting it.  \n\n2. You cannot take a rope with $length$ less than $K$.\n\n#### For Example:\n\n```\nInput : N = 4, X = 100, K = 45\n        Heights[] = [2, 5, 2, 6]\n           Rate[] = [10, 13, 15, 12]\nOutput : 4\n\nExplanation :\n\nDay 0 = [2, 5, 2, 6]\n\nDay 1 = [2 + 10, 5 + 13, 2 + 15, 6 + 12]         = [12, 18, 17, 18]\n\nDay 2 = [12 + 10, 18 + 13, 17 + 15, 18 + 12]     = [22, 31, 32, 30]\n\nDay 3 = [22 + 10, 31 + 13, 32 + 15, 30 + 12]     = [32, 44, 47, 42]\n\nDay 4 = [32 + 10, 44 + 13, 47 + 15, 42 + 12]     = [42, 57, 62, 54]\n\nAns : Day 4 as (57, 62, 54 are all greater than 45 and sum up to value that is greater than equal to 100)\n```\n***Can we use `Binary Search` here ?***  \n> We need to find the minimum days required to collect ropes that sum up to length `X`. The required day can be any day between $0$ to $10^{18}$. We can use `Binary Search` for finding the right day efficiently in `Logarithmic Time Complexity`.\n\n#### SOLVING APPROACH:\n\n**NOTE**: As the length of rope is increasing by a given pace so we can calculate its length at any particular day by :-  \n\n`Lenght at ith day = ith day * Rate of Growth + Initial length`\n\n1. The idea is to perform a `Binary Search` such that whenever we find a $day$ in which ropes length sum up to $X$, we will save it and search for a even lower value (as `Minimum days` are needed).  \n\n2. initialize `low` as $0$ and `high` as $10^{18}$, by this we understand that minimum days can be as low as value of `low` and as high as value of `high`.\n\n3. Calculate  $mid = (low + high)/2$, say $mid$ is our desired day.\n\n4. Now, Linearly traverse and check for all ropes if their length at $mid$ day is greater than or equal to $K$, if Yes add its value to a variable `Sum`.\n\n5. After traversal if `Sum` becomes greater or equal to $X$, simply save it, and check for a even lower value in the left half i.e. $(low - (mid - 1))$.\n\n6. Else, search in the right half i.e. $((mid + 1) - high)$.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n#define ll long long\n\nint main()\n{\n  ll N, X, K; scanf(\"%lld %lld %lld\", &N, &X, &K);\n  ll height[N], rate[N];\n  \n  //input heights of ropes\n  for(ll i=0; i<N; i++)\n    scanf(\"%lld\", &height[i]);\n    \n  //input rate of growth of ropes\n  for(ll i=0; i<N; i++)\n    scanf(\"%lld\", &rate[i]);\n    \n  //initialize minimum and maximum days that can be possible as low and high\n  ll low = 0;\n  ll high = 1000000000000000000;\n  ll min_days = 0;\n  \n  //Check for a mid value if it is satisfying the conditions\n while(low <= high){\n    ll mid = (low + high)/2;\n    ll sum = 0, flag = 0;\n    for(ll i=0 ;i<N; i++){\n      if(K <= (mid*rate[i] + height[i])){\n        sum += (mid*rate[i] + height[i]);\n        if(sum >= X){\n          flag = 1;\n          break;\n        }\n      }\n    }\n    \n    /* if mid is one of the possible day, save it and \n   keep on checking for more lower values in the left half */\n    if(flag == 1){\n      min_days = mid;\n      high = mid - 1;\n    }\n    /* if mid is not a possible day skip it and \n      go on searching in the right half */ \n   else\n      low = mid + 1;\n  }\n  printf(\"%lld\", min_days);\n    \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint main()\n{\n  ll N, X, K; cin>>N>>X>>K;\n  ll height[N], rate[N];\n  \n  //input heights of ropes\n  for(ll i=0; i<N; i++)\n    cin>>height[i];\n    \n  //input rate of growth of ropes\n  for(ll i=0; i<N; i++)\n    cin>>rate[i];\n    \n  //initialize minimum and maximum days that can be possible as low and high\n  ll low = 0;\n  ll high = 1000000000000000000;\n  ll min_days = 0;\n  \n  //Check for a mid value if it is satisfying the conditions\n  while(low <= high){\n   ll mid = (low + high)/2;\n    ll sum = 0, flag = 0;\n    for(ll i=0 ;i<N; i++){\n      if(K <= (mid*rate[i] + height[i])){\n        sum += (mid*rate[i] + height[i]);\n        if(sum >= X){\n          flag = 1;\n          break;\n }\n      }\n    }\n    \n    /* if mid is one of the possible day, save it and \n    keep on checking for more lower values in the left half */\n    if(flag == 1){\n      min_days = mid;\n      high = mid - 1;\n    }\n    /* if mid is not a possible day skip it and \n      go on searching in the right half */ \n    else\n      low = mid + 1;\n }\n  cout<<min_days;\n    \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\npublic class Main {\n    public static void main(String args[]){\n   \n      Scanner sc = new Scanner(System.in);\n      long N = sc.nextLong();\n      long X = sc.nextLong();\n      long K = sc.nextLong();\n      \n      long height[] = new long[(int)N];\n      long rate[] = new long[(int)N];\n   \n      //input heights of ropes\n      for(int i=0; i<N; i++)\n        height[i] = sc.nextLong();\n        \n     //input rate of growth of ropes\n      for(int i=0; i<N; i++)\n        rate[i] = sc.nextLong();\n        \n      //initialize minimum and maximum days that can be possible as low and high\n      long low = 0;\n      long high = 1000000000000000000L;\n      long min_days = 0;\n      \n      //Check for a mid value if it is satisfying the conditions\n      while(low <= high){\n        long mid = (low + high)/2;\n        long sum = 0, flag = 0;\n        for(int i=0 ;i<N; i++){\n          if(K <= (mid*rate[i] + height[i])){\n            sum += (mid*rate[i] + height[i]);\n if(sum >= X){\n              flag = 1;\n              break;\n            }\n          }\n        }\n        \n     /* if mid is one of the possible day, save it and \n        keep on checking for more lower values in the left half */\n        if(flag == 1){\n          min_days = mid;\n          high = mid - 1;\n        }\n        /* if mid is not a possible day skip it and \n          go on searching in the right half */ \n        else\n          low = mid + 1;\n      }\n      System.out.print(min_days);  \n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(NlogN)$\n\n3. $O(N^2)$\n\n4. $O(N)$\n \n**Time Complexity**: $O(NlogN)$, $logN$ for the `Binary Search` and $N$ for the `Linear Search` inside.\n\n**Space Complexity**: $O(1)$"
	}
]