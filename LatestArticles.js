module.exports = [
	{
		id: "array-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_resume_tips_freshers.jpg",
		heading: "Arithmetic Progression",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers, print the value of all those elements, whose indexes form an increasing",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Arithmetic Progression\n\n#### CONCEPTS USED:\nHashing, Basic Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers, print the value of all those elements, whose indexes form an increasing `Arithmetic Progression` along with the difference in `Arithmetic Progression`. If an element occurs single time then print $0$ as difference.\n\n#### For Example:\n```\nInput: \n\nN = 8\nA[] = [4, 2, 4, 3, 4, 2, 4, 5]\n\nOutput: \n\n4\n2 4\n3 0 \n4 2\n5 0\n\nExplanation:\n\n2 is present at index 1 and 5 which forms an A.P. with common difference 4 \n\n3 is present only at index 3 which is again an A.P. with common difference 0\n\n4 is present at index 0, 2, 4, and 6 which forms an A.P. with common difference 2\n\n5 is present only at index 7 which is again an A.P. with common difference 0\n```\n\n\n#### SOLVING APPROACH:\n\n1. It can be easily solved in `Linear Time Complexity` i.e. $O(N)$ but taking additional $O(N)$ space.\n\n2. Traverse the array and keep putting the elements into a `set`.\nA `set` is a data structure that contains unique elements.\n\n3. Maintain two different arrays for `difference value` and `last value` of an element and keep updating them.\n\n4. If the updated `difference value` does not matches the old value, this implies that the indices of this element are not in `Arithmetic Progression`. Therefore remove the element from the set.\n\n3. Finally print the elements and their `difference value` from the set.\n\n\n#### ILLUSTRATION:\n```\nA[] = [4, 2, 4, 3, 4]\n\ni = 0\nset = { }\n\n\nA[0] = 4 is not present in set, insert it\nset = {4}\ndiff[4] = 0\nlast_index[4] = i = 0\ni++;\n\ni = 1\nA[1] = 2 is not present in set, insert it\nset = {2, 4}\ndiff[2] = 0\nlast_index[2] = i =  1\ni++;\n\ni = 2\nA[2] = 4 is present in set, update last_index and difference\ndiff[4] = i - last_index[4] = 2 - 0 = 2\nlast_index[4] = i =  2\ni++;\n\ni = 3\nA[3] = 3 is not present in set, insert it\nset = {2, 3, 4}\ndiff[3] = 0\nlast_index[3] = i = 3\ni++ ;\n\ni = 4\nA[4] = 4 is present in set, update last_index and difference\n(if updated diff is not equal to previous diff, erase this element)\ndiff[4] = i - last_index[4] = 4 - 2 = 2\nlast_index[4] = i = 4\n\nNow print all elements of set along with their differences\n\nset = {2, 3, 4}\n\n3   (size of set)\n2 0 (diff[2])\n3 0 (diff[3])\n4 2 (diff[4])\n```\n\n\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint a1[100001],a2[100001];\nint b1[100001];\nint main() {\n    int n,a,o=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i) {\n        scanf(\"%d\",&a);\n    if(b1[a])\n        continue;\n    if(a1[a]) {\n        if(!a2[a])\n            a2[a]=i-a1[a];\n        else if(a2[a]!=i-a1[a])\n        {\n            b1[a]=1;--o;\n        }\n    }\n        else ++o;\n        a1[a]=i;\n   }\n    printf(\"%d\n\",o);\n    for(int i=1;i<100001;++i)\n        if(a1[i]&&!b1[i])\n            printf(\"%d %d\n\",i,a2[i]);\n}  \n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include<bits/stdc++.h>\n    using namespace std;\n    typedef long long int ll;\n    int main(){\n        ll n,a;\n        cin>>n;\n        ll diff[100005]={0},last_value[100005]={0};\n        bool b[100005];\n        set<ll>s;\n        memset(b,false,sizeof(b));\n     for(ll i=1;i<=n;i++){\n            cin>>a;\n            if(!b[a]){\n                s.insert(a);\n                b[a]=true;\n            }\n            else{\n                if(diff[a]&&(i!=diff[a]+last_value[a])){\n             s.erase(a);\n                }\n                diff[a]=i-last_value[a];\n            }\n            last_value[a]=i;\n        }\n        cout<<s.size()<<endl;\n        for(auto it=s.begin();it!=s.end();it++){\n            cout<<*it<<\" \"<<diff[*it]<<endl;\n        }\n    }\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n ```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int a1[] = new int[100001];\n    int a2[] = new int[100001];\n int b1[] = new int[100001];\n    int n = sc.nextInt();\n    int a,o=0;\n    \n    for(int i=1;i<=n;++i) {\n        a = sc.nextInt();\n    if(b1[a]>0)\n        continue;\n    if(a1[a]>0) {\n        if(a2[a] < 1)\n            a2[a]=i-a1[a];\n        else if(a2[a]!=i-a1[a])\n        {\n            b1[a]=1;--o;\n        }\n    }\n        else ++o;\n        a1[a]=i;\n    }\n    System.out.println(o);\n    for(int i=1;i<100001;++i)\n        if(a1[i]>0 && b1[i]<1)\n          System.out.println(i + \" \" + a2[i]);\n  }\n}\n ```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(N^2)$  \n\n2. $O(N*logN)$\n\n3. $O(logN)$\n\n4. $O(N)$\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, additional space used for `Hashing`.\n"
	},
	{
		id: "linklist-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_gd_mistakes.png",
		heading: "Binary list",
		category: "Linklist",
		date: "August 21 2019",
		desc: "Given a linked list of N nodes, each node containing binary bit either 0 or 1 as a character. Your task is to arrange nodes in such a way that no two consecutive nodes contain the same bit.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Binary list\n\n#### CONCEPTS USED:\nBasic Manipulation\n\n#### DIFFICULTY LEVEL:\nEasy\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a linked list of $N$ nodes, each node containing binary bit either $0$ or $1$ as a character. Your task is to arrange nodes in such a way that no two consecutive nodes contain the same bit.\n   \n***NOTE*** : The list must start from $0$ if there is more than one bit.  \n\n#### For Example:\n\n```\nInput : 100101\n\nOutput: 010101\n\nExplaination : As count of 0's and 1's are equal i.e. 3, so they can be arranged accordingly.\n```\n\n```\nInput : 11001\n\nOutput: -1\n\nExplaination : As count of 1's is greater than count of 0's, given string cannot be arranged in the required fashion.\n```\n\n#### OBSERVATION :\nWe can arrange our string in the required fashion if any of the two conditions are met - \n\ncount of $0$'s is equal to count of $1$'s \n\ncount of $0$'s is equal to count of $1$'s $+ 1$\n\n#### SOLVING APPROACH:\n\n1. Calculate the count of $0$'s and $1$'s in `zeros` and `ones`.  \n\n2. Check if the string is empty or contains only $1$ char, in this case our string is already arranged so return.\n\n3. Check if `zeros` = `ones` or `zeros` = `ones + 1`, if true one-by-one keep assigning the values of $0$ and $1$ to the string linearly. Else return.\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\nNode* BinaryList(Node *head)\n{\n    /* If list is empty or it contains only 1 bit */\n    if(head == NULL || head -> next == NULL)\n      return head;\n      \n    Node *temp = head;\n    int ones = 0, zeros = 0;\n    \n    /* Calculate count of 0's and 1's in the list */\n    while(temp){\n      if(temp -> value == '1')\n        ones++ ;\n      else\n        zeros++ ;\n      temp = temp -> next;\n    }\n    \n    temp = head;\n    int flag = 1;\n    \n    /* if count of 0's and 1's is valid arrange them accordingly */\n    if((zeros == ones) || (zeros == (ones + 1))){\n   while(temp){\n        if(flag){\n          temp -> value = '0';\n          flag = 0;\n        }\n        else{\n   temp -> value = '1';\n          flag = 1;\n        }\n        temp = temp -> next;\n      }\n      return head;\n   }\n    \n    /* if count of 0's and 1's is not valid return NULL */\n    else\n      return NULL;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\nNode* BinaryList(Node *head)\n{\n    /* If list is empty or it contains only 1 bit */\n    if(head == NULL || head -> next == NULL)\n      return head;\n      \n    Node *temp = head;\n   int ones = 0, zeros = 0;\n    \n    /* Calculate count of 0's and 1's in the list */\n    while(temp){\n      if(temp -> value == '1')\n        ones++ ;\n      else\n        zeros++ ;\n      temp = temp -> next;\n    }\n    \n    temp = head;\n    int flag = 1;\n    \n    /* if count of 0's and 1's is valid arrange them accordingly */\n    if((zeros == ones) || (zeros == (ones + 1))){\n      while(temp){\n        if(flag){\n          temp -> value = '0';\n flag = 0;\n        }\n        else{\n          temp -> value = '1';\n          flag = 1;\n        }\n        temp = temp -> next;\n      }\n      return head;\n    }\n    \n    /* if count of 0's and 1's is not valid return NULL */\n    else\n      return NULL;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nstatic SinglyLinkedListNode BinaryList(SinglyLinkedListNode head)\n{\n    /* If list is empty or it contains only 1 bit */\n    if(head == null || head.next == null)\n      return head;\n      \n    SinglyLinkedListNode temp = head;\n    int ones = 0, zeros = 0;\n    \n    /* Calculate count of 0's and 1's in the list */\n    while(temp != null){\n      if(temp.value == '1')\n        ones++ ;\n      else\n        zeros++ ;\n      temp = temp.next;\n    }\n    \n    temp = head;\n int flag = 1;\n    \n    /* if count of 0's and 1's is valid arrange them accordingly */\n    if((zeros == ones) || (zeros == (ones + 1))){\n      while(temp != null){\n        if(flag == 1){\n          temp.value = '0';\n         flag = 0;\n        }\n        else{\n          temp.value = '1';\n          flag = 1;\n        }\n        temp = temp.next;\n      }\n      return head;\n    }\n    \n    /* if count of 0's and 1's is not valid return NULL */\n   else\n      return null;\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(logN)$  \n\n2. $O(N*logN)$\n\n3. $O(N)$\n\n4. $O(N^2)$\n\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$"
	},
	{
		id: "recursion-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_face_interview_freshers.jpg",
		heading: "Mike and Binary Number",
		category: "Recursion",
		date: "August 21 2019",
		desc: "Given a number N, your task is to print all possible permutations of its Binary Representation.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Mike and Binary Number\n\n#### CONCEPTS USED:\nRecursion\n\n#### DIFFICULTY LEVEL:\nMedium\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven a number $N$, your task is to print all possible permutations of its `Binary Representation`.\n\n***NOTE*** : Print the output in the lexicographically sorted form.\n\n#### For Example :\n\n```\nInput : N = 5\n\nOutput : 011 101 110\n\nExplanation : \n\nBinary Representation of 5 is 101 and all permutations of it i.e. 011 101 110 are printed in a lexicographic order.\n```\n\n#### SOLVING APPROACH:\n\n1. Start by finding the number of zeros and ones present in the `Binary Representation` of $N$ and store them in `ones` and `zeros`.   \n\n2. Initialize an empty string `str` for storing all such combinations one-by-one.\n\n3. If `ones` = 0, append all the `zeros` to `str` and print it. Else if `zeros` = 0, append all `ones` to `str` and print it.\n\n4. Else recursively keep appending a $0$ to `str` and reduce `zeros` by $1$. Similarly recursively keep appending a $1$ to `str` and reduce `ones` by $1$ till all `zeros` and `ones` are appended in the `str` and its size becomes equal to size of the `Binary Representation` of the number $N$.\n\n#### ILLUSTRATION :\n\n```\nN = 5 \nBinary Representation of 5 = 101\nZeros = 1\nOnes = 2\nstr = \"\"\n\nSince Zeros and Ones both are not 0, append 0 to str and reduce Zeros by 1\nstr = \"0\"\nZeros = 0\n\nSince Zeros = 0, append all remaining 1's to str\nstr = \"011\"\nOnes = 0\n\nSince Zeros = Ones = 0\nprint the str i.e. our first valid permutation of Binary Representation of 5.\n\nSimilarly print all such permutations recursively.\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* function for finding all such combinations */\nvoid permutation(int no_ones, int no_zeroes, string accum,vector<string>&perm){\n   if(no_ones == 0){\n       for(int i=0;i<no_zeroes;i++){\n     accum += \"0\";\n       }\n       perm.push_back(accum);\n       return;\n   }\n   else if(no_zeroes == 0){\n       for(int j=0;j<no_ones;j++){\n           accum += \"1\";\n       }\n       perm.push_back(accum);\n       return;\n }\n\n   permutation (no_ones - 1, no_zeroes, accum + \"1\",perm);\n   permutation (no_ones , no_zeroes - 1, accum + \"0\",perm);\n}\n\nint main(){\n   int t;\n   cin>>t;\n   while(t--){\n   int n, ones = 0, zeros = 0;\n   cin>>n;\n \n   /* finding number of zeros and ones in the number */\n   while(n>0)\n   {\n       if(n&1)\n           ones++;\n       else\n        zeros++;\n      n =n>>1;    \n   }\n   \n   //initializing an empty string\n   string append = \"\";\n   \n   //vector of strings to store all the combinations \n   vector<string>perm;\n     \n    \n   permutation(ones, zeros, append, perm);  \n   \n   /* sort all combinations in ascending order */\n   sort(perm.begin(),perm.end());\n   \n   for(int i=0;i<perm.size();i++)\n     cout<<perm[i]<<\" \";\n   }\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  \n   /* function for finding all such combinations */\n  static void permutation(int no_ones, int no_zeroes, String accum, ArrayList<String> perm){\n     if(no_ones == 0){\n         for(int i=0;i<no_zeroes;i++){\n             accum += \"0\";\n     }\n         perm.add(accum);\n         return;\n     }\n     else if(no_zeroes == 0){\n         for(int j=0;j<no_ones;j++){\n             accum += \"1\";\n         }\n         perm.add(accum);\n         return;\n     }\n  \n     permutation (no_ones - 1, no_zeroes, accum + \"1\",perm);\n     permutation (no_ones , no_zeroes - 1, accum + \"0\",perm);\n  }\n\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n  \n    while(t != 0){\n    int n = sc.nextInt();\n    int ones = 0, zeros = 0;\n    \n    /* finding number of zeros and ones in the number */\n    while(n>0)\n    {\n       if(n%2 == 0)\n   zeros++;\n       else\n          ones++;\n      n /= 2;    \n    }\n    \n    //initializing an empty string\n    String append = \"\";\n    \n    //vector of strings to store all the combinations \n    //vector<string>perm;\n    ArrayList<String> perm = new ArrayList<String>(); \n     \n    \n    permutation(ones, zeros, append, perm);  \n   \n    /* sort all combinations in ascending order */\n    Collections.sort(perm);\n    \n    for(int i=0;i<perm.size();i++)\n      System.out.print(perm.get(i) + \" \");\n    System.out.println();\n    \n    t--;\n    }\n  }\n}\n```\n\n#### What do you think `Time Complexity` of this solution can be ? \n\n1. $O(N^2)$  \n\n2. $O(2^N)$\n\n3. $O(N*2^N)$\n\n4. $O(N^2 * 2^N)$\n \n**Time Complexity**: $O(N*2^N)$\n"
	},
	{
		id: "searching-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/start_preparation_blog.jpg",
		heading: "Maximize The Boxes",
		category: "Searching",
		date: "August 21 2019",
		desc: "Given chocolates of 3 types A, B, C with their frequencies f A,f B and f C, you need to pack these chocolates in a box. Maximize the number of boxes for given f A,f B and f C. Q queries will be asked.",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Maximize The Boxes \n\n#### CONCEPTS USED:\nSearching, Basic Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\n\nGiven chocolates of $3$ types $A, B, C$ with their frequencies $f_A$,$f_B$ and $f_C$, you need to pack these chocolates in a box. Maximize the number of boxes for given $f_A$,$f_B$ and $f_C$. $Q$ queries will be asked.\n\n#### CONDITIONS:\n\n1. Box should contain exactly $3$ chocolates.  \n\n2. It should contain at least $1$ type of chocolate $A$ and $1$ type of chocolate $B$.\n\nAllowed : $(A,B,C) , (A,A,B), (A,B,B)$ \n\nNot Allowed : $(C,C,A) , (A,A,A)$ $etc$\n\n#### For Example:\n\n```\nInput : 4 2 1\n\nOutput : 2\n\nExplanation : Every box should have atleast 1 chocolate of type A and 1 chocolate of type B, so she have only arrangement possible - \n\n(A B C) => we have single C, which is used here\n(A B A) => out of two B's, last B is used here\n\nTherefore, Maximum of 2 boxes can be made.\n```\n\n```\nInput : 5 4 0\n\nOutput : 3\n\nExplanation : Every box should have at least 1 chocolate of type A and 1 chocolate of type B, so she have only arrangement possible - \n\n(A B A) => 3 A's and 3 B's left\n(A B B) => 2 A's and 1 B left\n(A A B) => all A's and B's used\n\nTherefore, Maximum of 3 boxes can be made.\n```\n\n#### SOLVING APPROACH:\n\n1. The approach is quite simple as there are only two cases to cover.  \n\n2. If `minimum` frequency between A and B is less than or equal to frequency of C, than `minimum` frequency between A and B is our answer, as Chocolate $A$ and $B$ are essential in every box so the `minimum` of these two will be the result.\n\n3. Else if `minimum` frequency between $A$ and $B$ is greater than frequency of $C$, this implies that putting only $1-1$ chocolate $A$ and chocolate $B$ are not sufficient in each box as there are insufficient chocolate $C$ for all such boxes.\n\n4. So, calculate the `Sum` of frequency of all the three boxes and divide it by $3$.\n\n5. The `minimum` between this `Sum` and `minimum` frequency between $A$ and $B$ will be our answer. \n\n#### ALGORITHM:\n\n```\nmin_f_AB = minimum of (frequency of A , frequency of B)\nSum_f_ABC = (frequency of A + frequency of B + frequency of C)/3\n\n\nif (min_f_AB <= frequency of C)\n    print min_f_AB\nelse\n    if(Sum_f_ABC < min_f_AB)\n        print Sum_f_ABC\n    else\n        print min_f_AB\n```\n\n#### ILLUSTRATION:\n\n```\n2 2 2\n\nMin of A and B <= C i.e. (2 <= 2)\nSo, Maximum boxes is Min of A and B i.e. 2\n```\n\n```\n4 2 1 \n\nMin of A and B > C i.e. (2 > 1)\nSo calculate average of all frequencies and check whether it is (< Min of A and B)\nsum = (A + B + C) / 3 = (4 + 2 + 1) / 3 = 2\nSince, sum < Min of A and B\nso sum is our Maximum number of boxes i.e. 2\n```\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int q; scanf(\"%d\", &q);\n  while(q--){\n    int f_a, f_b, f_c, min_ab;\n    scanf(\"%d %d %d\", &f_a, &f_b, &f_c);\n    \n    // find mininum among f_a and f_b\n    if(f_a < f_b)\n      min_ab = f_a;\n    else\n      min_ab = f_b;\n   \n    // print the minimum of (f_a, f_b) and f_c \n    if(min_ab <= f_c){\n      printf(\"%d\n\", min_ab);\n    }\n    \n /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n    else{\n      int sum = (f_a + f_b + f_c)/3;\n      if(sum < min_ab)\n        printf(\"%d\n\", sum);\n      else \n        printf(\"%d\n\", min_ab);\n    }\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int q; cin>>q;\n  while(q--){\n    int f_a, f_b, f_c ;\n    cin>>f_a>>f_b>>f_c ;\n    \n    // print the minimum of (f_a, f_b) and f_c \n    if(min(f_a, f_b) <= f_c){\n      cout<<min(f_a, f_b)<<\"\n\";\n    }\n    \n    /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n    else{\n      int sum = (f_a + f_b + f_c)/3;\n      cout<<min(sum, min(f_a, f_b)) <<\"\n\";\n    }\n  }\n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\nimport java.lang.Math;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int q = sc.nextInt();\n    \n    while(q != 0){\n      int f_a = sc.nextInt();\n      int f_b = sc.nextInt();\n      int f_c = sc.nextInt();\n     \n      // print the minimum of (f_a, f_b) and f_c \n      if(Math.min(f_a, f_b) <= f_c){\n        System.out.println(Math.min(f_a, f_b));\n }\n      \n      /* print minimum of (sum of frequencies divided by 3) and\n     (minimum of (f_a, f_b) ) */\n     else{\n        int sum = (f_a + f_b + f_c)/3;\n        System.out.println(Math.min(sum, Math.min(f_a, f_b)));\n     }\n      q--;\n    }\n  }\n}\n```\n\n#### Can you guess the `Time Complexity` of the solution ?\n\n1. $O(logN)$  \n\n2. $O(NlogN)$\n\n3. $O(N^2)$\n\n4. $O(N)$\n\nwhere $N =$ $Number$ $of$ $queries$\n \n**Time Complexity**: $O(N)$\n \n**Space Complexity**: $O(1)$"
	}
]