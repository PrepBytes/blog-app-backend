module.exports = [
	{
		id: "array-1",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_resume_tips_freshers.jpg",
		heading: "Arithmetic Progression",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers, print the value of all those elements, whose indexes form an increasing",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Arithmetic Progression\n\n#### CONCEPTS USED:\nHashing, Basic Mathematics\n\n#### DIFFICULTY LEVEL:\nHard\n\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers, print the value of all those elements, whose indexes form an increasing `Arithmetic Progression` along with the difference in `Arithmetic Progression`. If an element occurs single time then print $0$ as difference.\n\n#### For Example:\n```\nInput: \n\nN = 8\nA[] = [4, 2, 4, 3, 4, 2, 4, 5]\n\nOutput: \n\n4\n2 4\n3 0 \n4 2\n5 0\n\nExplanation:\n\n2 is present at index 1 and 5 which forms an A.P. with common difference 4 \n\n3 is present only at index 3 which is again an A.P. with common difference 0\n\n4 is present at index 0, 2, 4, and 6 which forms an A.P. with common difference 2\n\n5 is present only at index 7 which is again an A.P. with common difference 0\n```\n\n\n#### SOLVING APPROACH:\n\n1. It can be easily solved in `Linear Time Complexity` i.e. $O(N)$ but taking additional $O(N)$ space.\n\n2. Traverse the array and keep putting the elements into a `set`.\nA `set` is a data structure that contains unique elements.\n\n3. Maintain two different arrays for `difference value` and `last value` of an element and keep updating them.\n\n4. If the updated `difference value` does not matches the old value, this implies that the indices of this element are not in `Arithmetic Progression`. Therefore remove the element from the set.\n\n3. Finally print the elements and their `difference value` from the set.\n\n\n#### ILLUSTRATION:\n```\nA[] = [4, 2, 4, 3, 4]\n\ni = 0\nset = { }\n\n\nA[0] = 4 is not present in set, insert it\nset = {4}\ndiff[4] = 0\nlast_index[4] = i = 0\ni++;\n\ni = 1\nA[1] = 2 is not present in set, insert it\nset = {2, 4}\ndiff[2] = 0\nlast_index[2] = i =  1\ni++;\n\ni = 2\nA[2] = 4 is present in set, update last_index and difference\ndiff[4] = i - last_index[4] = 2 - 0 = 2\nlast_index[4] = i =  2\ni++;\n\ni = 3\nA[3] = 3 is not present in set, insert it\nset = {2, 3, 4}\ndiff[3] = 0\nlast_index[3] = i = 3\ni++ ;\n\ni = 4\nA[4] = 4 is present in set, update last_index and difference\n(if updated diff is not equal to previous diff, erase this element)\ndiff[4] = i - last_index[4] = 4 - 2 = 2\nlast_index[4] = i = 4\n\nNow print all elements of set along with their differences\n\nset = {2, 3, 4}\n\n3   (size of set)\n2 0 (diff[2])\n3 0 (diff[3])\n4 2 (diff[4])\n```\n\n\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint a1[100001],a2[100001];\nint b1[100001];\nint main() {\n    int n,a,o=0;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i) {\n        scanf(\"%d\",&a);\n    if(b1[a])\n        continue;\n    if(a1[a]) {\n        if(!a2[a])\n            a2[a]=i-a1[a];\n        else if(a2[a]!=i-a1[a])\n        {\n            b1[a]=1;--o;\n        }\n    }\n        else ++o;\n        a1[a]=i;\n   }\n    printf(\"%d\n\",o);\n    for(int i=1;i<100001;++i)\n        if(a1[i]&&!b1[i])\n            printf(\"%d %d\n\",i,a2[i]);\n}  \n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include<bits/stdc++.h>\n    using namespace std;\n    typedef long long int ll;\n    int main(){\n        ll n,a;\n        cin>>n;\n        ll diff[100005]={0},last_value[100005]={0};\n        bool b[100005];\n        set<ll>s;\n        memset(b,false,sizeof(b));\n     for(ll i=1;i<=n;i++){\n            cin>>a;\n            if(!b[a]){\n                s.insert(a);\n                b[a]=true;\n            }\n            else{\n                if(diff[a]&&(i!=diff[a]+last_value[a])){\n             s.erase(a);\n                }\n                diff[a]=i-last_value[a];\n            }\n            last_value[a]=i;\n        }\n        cout<<s.size()<<endl;\n        for(auto it=s.begin();it!=s.end();it++){\n            cout<<*it<<\" \"<<diff[*it]<<endl;\n        }\n    }\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n ```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int a1[] = new int[100001];\n    int a2[] = new int[100001];\n int b1[] = new int[100001];\n    int n = sc.nextInt();\n    int a,o=0;\n    \n    for(int i=1;i<=n;++i) {\n        a = sc.nextInt();\n    if(b1[a]>0)\n        continue;\n    if(a1[a]>0) {\n        if(a2[a] < 1)\n            a2[a]=i-a1[a];\n        else if(a2[a]!=i-a1[a])\n        {\n            b1[a]=1;--o;\n        }\n    }\n        else ++o;\n        a1[a]=i;\n    }\n    System.out.println(o);\n    for(int i=1;i<100001;++i)\n        if(a1[i]>0 && b1[i]<1)\n          System.out.println(i + \" \" + a2[i]);\n  }\n}\n ```\n\n#### Can you guess the `Time Complexity` of the solution ? \n\n1. $O(N^2)$  \n\n2. $O(N*logN)$\n\n3. $O(logN)$\n\n4. $O(N)$\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, additional space used for `Hashing`.\n"
	},
	{
		id: "array-2",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_mock_interview.jpg",
		heading: "Array Max",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers and an integer K, the task is to find the maximum sum taking every K",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Array Max\n\n#### CONCEPTS USED:\nSuffix Sum Arrays\n\n#### DIFFICULTY LEVEL:\nHard\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers and an integer $K$, the task is to find the maximum sum taking every $K^{th}$ element i.e. \n\n$sum$ $= arr[i] + arr[i + k] + arr[i + 2 *k] + arr[i + 3 * k] + ... arr[i+ q * k]$ \n\nstarting with any $i$ value.\n\n**NOTE**: \n1. He can stop moving to \n$(i+k)^{th}$ index\n at any time he wishes.  \n\n2. Minimum value that sum can have is zero, it should never become negative throughout the calculation.  \n\n#### For Example: \n```\nInput : N = 5, K = 2\n        A[] = [1, 2, 3, 4, 5]\n\nOutput : 9\n\nExplanation : Start with index = 0 and sum = 0\n\nsum = sum + A[0] = 0 + 1 = 1\ni = i + 2 = 0 + 2 = 2\n\nsum = sum + A[2] = 2 + 3 = 5\ni = i + 2 = 2 + 2 = 4\n\nsum = sum + A[4] = 4 + 5 = 9\ni = i + 2 = 4 + 2 = 6\n\nSimilarly starting from other indexes and finding sum values, we obtain that\n9 is the maximum sum that can be obtained.\n```\n\n#### BRUTEFORCE METHOD:\n\n1.  Begin with choosing a starting `index`$(i = 0)$, adding value at this `index` to the `sum`, comparing `sum` with `max value` and updating `max value`. Keep taking $K$ steps and updating `max value` till $i$ becomes equal to $N$.\n\n2. Follow `Step-1` for all such `indexes` and finally find the `maximum sum` out of all such sum values.\n  \n3. `Time Complexity` of this solution is $O(N^2)$ as we will be running two nested loops.\n\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    for(int i=0;i<n;i++)\n      scanf(\"%d\",&arr[i]);\n    int max_val = 0;\n    int sum = 0;\n    for(int i=0;i<n;i++)\n    {\n      sum = 0;\n      int j=i;\n      while(j<n)\n      {\n        if(sum+arr[j]<0)\n        {\n          sum=0;\n        }\n        else\n   sum += arr[j];\n        if(sum>max_val)\n          max_val = sum;\n        j += k;\n      }\n    }\n    printf(\"%d\n\",max_val);\n  }\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n    for(int i=0;i<n;i++)\n      cin>>arr[i];\n    int max_val = 0;\n    int sum = 0;\n    for(int i=0;i<n;i++)\n    {\n      sum = 0;\n      int j=i;\n      while(j<n)\n      {\n        if(sum+arr[j]<0)\n        {\n       sum=0;\n        }\n        else\n          sum += arr[j];\n        max_val = max(sum,max_val);\n        j += k;\n   }\n    }\n    cout<<max_val<<\"\n\";\n  }\n  \n  return 0;\n}\n```\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n    while(t!=0)\n    {\n   int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      for(int i=0;i<n;i++)\n     arr[i] = sc.nextInt();\n      int max_val = 0;\n      int sum = 0;\n      for(int i=0;i<n;i++)\n      {\n        sum = 0;\n        int j=i;\n        while(j<n)\n        {\n          if(sum+arr[j]<0)\n          {\n            sum=0;\n          }\n          else\n            sum += arr[j];\n          if(sum>max_val)\n            max_val = sum;\n j += k;\n        }\n      }\n      System.out.println(max_val);\n      t--;\n    }   \n  }\n}\n```\n\nTime Complexity : $O(N^2)$\n\nSpace Complexity: $O(1)$\n\n\n\n#### EFFICIENT METHOD:\n1. It can be solved by using the concept of `Suffix Sum Arrays` where we start iterating the array from right side and keep storing the suffix sum for each $(i+k)^{th}$ element where $(i+k)<n$.  \n\n2. Finally we find the maximum sum from the `Suffix Sum Array`.\n\n***What are Suffix Sum Arrays?***\n`Suffix Sum Arrays` are of same size of the normal array such that the $i^{th}$ index of this array stores the sum of values from $i{th}$ index value to the last value of the original array i.e.      \n \n$SuffixArray[i] = A[i] + A[i+1] + .... + A[N-1]$ \n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint main()\n{\n  int t;\n  scanf(\"%d\",&t);\n  while(t--)\n  {\n    int n,k;\n    scanf(\"%d %d\",&n,&k);\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n       scanf(\"%d\",&arr[i]);\n    }\n     \n int max_val = 0;\n    int sum[n];\n    for(int i=0;i<n;i++)\n      sum[i] = 0;\n    \n    for(int i=n-1;i>=0;i--)\n {\n      if(i+k < n)\n      {\n        if(arr[i]+sum[i+k]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i]+sum[i+k];\n      }\n      else\n      {\n        if(arr[i]<0)\n          sum[i] = 0;\n        else\n       sum[i] = arr[i];\n      }\n      if(sum[i]>max_val)\n        max_val = sum[i];\n    }\n    printf(\"%d\n\",max_val);\n  }\n  \n  return 0;\n}\n\n```\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int t;cin>>t;\n  while(t--)\n  {\n    int n,k;cin>>n>>k;\n    int arr[n];\n   for(int i=0;i<n;i++)\n    {\n       cin>>arr[i];\n    }\n     \n    int max_val = 0;\n    int sum[n];\n    for(int i=0;i<n;i++)\n      sum[i] = 0;\n    \n    for(int i=n-1;i>=0;i--)\n    {\n      if(i+k < n)\n      {\n        if(arr[i]+sum[i+k]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i]+sum[i+k];\n      }\n      else\n {\n        if(arr[i]<0)\n          sum[i] = 0;\n        else\n          sum[i] = arr[i];\n      }\n        \n      max_val = max(max_val,sum[i]);\n    }\n    cout<<max_val<<\"\n\";\n  }\n  \n  return 0;\n}\n\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n```java\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n  public static void main(String args[]) throws IOException {\n    Scanner sc = new Scanner(System.in);\n    int t = sc.nextInt();\n while(t!=0)\n    {\n      int n = sc.nextInt();\n      int k = sc.nextInt();\n      int arr[] = new int[n];\n      for(int i=0;i<n;i++)\n      {\n         arr[i] = sc.nextInt();\n      }\n      int max_val = 0;\n      int sum[] = new int[n];\n      \n      for(int i=n-1;i>=0;i--)\n      {\n        if(i+k < n)\n        {\n          if(arr[i]+sum[i+k]<0)\n            sum[i] = 0;\n          else\n            sum[i] = arr[i]+sum[i+k];\n        }\n        else\n        {\n          if(arr[i]<0)\n            sum[i] = 0;\n          else\n            sum[i] = arr[i];\n        }\n        if(sum[i]>max_val)\n          max_val = sum[i];\n      }\n      System.out.println(max_val);\n      t--;\n    }  \n  }\n}\n```\n#### Can you guess the `Time Complexity` of the `Efficient` solution ? \n\n1. $O(N)$  \n\n2. $O(NlogN)$\n\n3. $O(logN)$\n\n4. $O(N^2)$\n \nTime Complexity: $O(N)$\n\nSpace Complexity: $O(N)$, due to `Suffix Array` taking additional memory.\n"
	},
	{
		id: "array-3",
		img: "https://s3.ap-south-1.amazonaws.com/blog-images-upload/blog_how_to_clear_aptitude_test.jpg",
		heading: "Array ZigZag",
		category: "Array",
		date: "August 21 2019",
		desc: "Given an array of N integers, convert it into a ZigZag array by choosing any element",
		author: "PrepBytes",
		posted_on: "Mon Aug 24 2020 01:25:52 GMT+0530",
		author_img: "https://s3.ap-south-1.amazonaws.com/www.prepbytes.com/images/logoPrepBytesMbl.png",
		claps: 25,
		content: "# Array ZigZag\n\n#### CONCEPTS USED:\nArrays\n\n#### DIFFICULTY LEVEL:\nHard\n\n\n#### PROBLEM STATEMENT$($SIMPLIFIED$)$:\nGiven an array of $N$ integers, convert it into a `ZigZag` array by choosing any element and decrementing it by $1$.\n\nAn array $A$ is a `ZigZag` array if either:\n\n1. Every even-indexed element is greater than its adjacent elements, ie. $A0 > A1 < A2 > A3 < A4 > ...$\n\n2. OR, every odd-indexed element is greater than its adjacent elements, ie. $A0 < A1 > A2 < A3 > A4 < ...$\n\nPrint the minimum number of moves to transform the given array into a `ZigZag` array.\n\n#### For Example:\n```\nInput: N = 3 \n       A[] = [2, 3, 4]\n\nOutput: 2\n\nExplanation: \n\nWe can decrease 3 to 1 to form [2, 1, 4] so that all even indexed elements are greater than the neighbours. Hence output is 2.\n```\n\n#### SOLVING APPROACH:\n\n>1. We will solve this problem two times.\n>>1. For the even-indexed array.  \n>>\n>>2. For the odd-indexed array.\n>2. `Minimum` of both the solutions will be our desired solution.  \n>\n>2. Start traversing the array, for each element find the `minimum` value among the element , previous element $- 1$ and next element $- 1$.\n>3. The difference between current element and calculated `minimum` value is the moves required to correctly position these three elements.\n>3. Similarly, keep doing it for the entire array and keep track of a `sum` variable.\n>>$sum$   $+= ( A[i] - min(A[i],A[i-1]-1,A[i+1]-1) )$\n\n#### SOLUTIONS:\n\n#### ONE EXPECTED SOLUTION$($C$)$:\n\n```c\n#include <stdio.h>\n\nint solve(int arr[],int n,int start)\n{\n  int res = 0;\n  for(int i=start;i<n;i+=2)\n  {\n    int to = arr[i];\n    if(i)\n    // make sure current element is less than its left neighboor\n    {\n      if(arr[i-1]-1<to)\n        to = arr[i-1]-1;\n    }\n    if(i+1 != n)\n    // make sure current element is less than its right neighboor\n    {\n      if(arr[i+1]-1<to)\n        to = arr[i+1]-1;\n    }\n // if curr value was decreased to \"to\", add the difference\n    res += arr[i] - to;\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  int arr[n];\n  for(int i=0;i<n;i++)\n    scanf(\"%d\",&arr[i]);\n  int res1 = solve(arr,n,0);\n  int res2 = solve(arr,n,1);\n  \n  if(res1 < res2)\n    printf(\"%d\",res1);\n  else\n    printf(\"%d\",res2);\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($C++$)$:\n \n ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(int arr[],int n,int start)\n{\n  int res = 0;\n  for(int i=start;i<n;i+=2)\n  {\n    int to = arr[i];\n    if(i){\n    // make sure current element is less than its left neighboor\n     to = min(to,arr[i-1]-1);\n    }\n    if(i+1 != n){\n    // make sure current element is less than its right neighboor\n      to = min(to,arr[i+1]-1);\n    }\n    // if curr value was decreased to \"to\", add the difference\n    res += arr[i] - to;\n  }\n  return res;\n}\n\nint main()\n{\n  int n;cin>>n;\n  int arr[n];\n  for(int i=0;i<n;i++)\n cin>>arr[i];\n  \n  cout<<min(solve(arr,n,0),solve(arr,n,1));\n  \n  return 0;\n}\n```\n\n#### ONE EXPECTED SOLUTION$($JAVA$)$:\n\n```java\nimport java.util.*;\nimport java.io.*;\nimport java.lang.Math;\n\npublic class Main {\n  static int solve(int arr[],int n,int start)\n  {\n    int res = 0;\n    for(int i=start;i<n;i+=2)\n    {\n      int to = arr[i];\n      if(i>0)\n      // make sure current element is less than its left neighboor\n        to = Math.min(to,arr[i-1]-1);\n      if(i+1 != n)\n      // make sure current element is less than its right neighboor\n     to = Math.min(to,arr[i+1]-1);\n      // if curr value was decreased to \"to\", add the difference\n      res += arr[i] - to;\n    }\n    return res;\n  }\n  public static void main(String args[]) throws IOException {\n    \n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int arr[] = new int[n];\n    for(int i=0;i<n;i++)\n      arr[i] = sc.nextInt();\n    \n    System.out.println(Math.min(solve(arr,n,0),solve(arr,n,1)));\n  }\n}\n ```\n\n#### Can you guess the `Time Complexity` of the solution ? \n1. $O(N)$  \n\n2. $O(N*logN)$\n\n3. $O(logN)$\n\n4. $O(N^2)$\n\nTime Complexity: $O(N)$\n\nSpace Complexity: $O(1)$\n"
	}
]